#version 150

in vec2 out_texcoords;


#define MATH_PI         3.1415926536
#define MATH_PI_DIV_2   1.5707963268

const mat3 XYZ2LinearsRGB
    = mat3(3.1338561, -0.9787684,  0.0719453,
           -1.6168667, 1.9161415, -0.2289914,
            -0.4906146, 0.0334540, 1.4052427);

void main()
{
    float radius = length(out_texcoords);

    vec3 XYZ = vec3(0.0);
    
    if (radius <= radiusInPixel)
    {
        //  http://en.wikipedia.org/wiki/Stereographic_projection
        float X = out_texcoords.x / radiusInPixel;
        float Y = out_texcoords.y / radiusInPixel;
        float l = 1.0 + X*X + Y*Y;

        //  stereographic projection using southpole
        float x = 2*X / l;
        float y = 2*Y / l;
        float z = (1.0 - X*X - Y*Y) / l;

        // http://de.wikipedia.org/wiki/Kugelkoordinaten
        // float phiAngle = atan(y, x);
        float thetaAngle = MATH_PI_DIV_2 - atan(z / length(vec2(x, y)));

        // convert to OpenGL coord system
        vec3 v = vec3(x, y, z);
        v = normalize(v);

        float cosGamma = clamp(dot(v, directionToSun), -1.0, 1.0);
        float gamma = acos(cosGamma);

        vec3 numerator = (1.0f + A * exp( B / cos(thetaAngle) )) * (1.0f + C * exp( D * gamma ) + (E * cosGamma * cosGamma));
        vec3 xyY = zenithColor * (numerator / denominator);

        XYZ.x = (xyY.x / xyY.y) * xyY.z;
        XYZ.y = xyY.z;
        XYZ.z = ((1.0f - xyY.x - xyY.y) / xyY.y) * xyY.z;

        float f = gamma - sunHalfApparentAngle;

        float a = 200.0;
        float b = 1.0;
        float c = 150.0;

        float falloff = (1.0 / exp(a * f)) + b * (1.0 / exp(c * f));
        falloff = clamp(falloff, 0.0, 1.0);

        /*
        vec3 zs = vec3(zenithColor.x, zenithColor.y, sunColor.y);
        vec3 zenithColorXYZ;
        zenithColorXYZ.x = (zs.x / zs.y) * zs.z;
        zenithColorXYZ.y = zs.z;
        zenithColorXYZ.z = ((1.0f - zs.x - zs.y) / zs.y) * zs.z;
        */

        XYZ += falloff * sunColor;

        if ( cosGamma >= cos(sunHalfApparentAngle) )
        {
            XYZ += sunColor;
        }
    }
    else
    {
        const float avgFresnel = 0.17;
        XYZ = (irradiance / MATH_PI);// * avgFresnel;
    }

    target = vec4(XYZ2LinearsRGB * XYZ, 1.0);
}
