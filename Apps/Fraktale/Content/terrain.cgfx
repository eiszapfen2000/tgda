float4x4 mvp : NPMODELVIEWPROJECTION;
float3 lightDirection;
sampler2D colormap0 : NPCOLORMAP0;

struct INPUTDATA
{
	float4 position			: POSITION;
    float3 normal           : NORMAL;
	float2 texcoord		    : TEXCOORD0;
    float3 AO               : COLOR0;
};

struct VOUTPUTDATA
{
	float4 position			: POSITION;
	float2 texcoord			: TEXCOORD0;
    float3 normal           : TEXCOORD1;
    //float3 worldPosition    : TEXCOORD2;
    float3 AO               : TEXCOORD3;
};

VOUTPUTDATA mvertexshader(INPUTDATA input)
{
	VOUTPUTDATA output;

	output.position = mul(mvp, input.position);
    output.texcoord = input.texcoord;
    output.normal   = input.normal;
    //output.worldPosition = input.position.xyz;
    output.AO = input.AO;
	
	return output;
}

struct FOUTPUTDATA
{
	float4 color			: COLOR0;
};

FOUTPUTDATA mfragmentshader(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float3 normal = normalize(input.normal);
    float factor = max(0.0f, dot(normal, lightDirection));
    float ambient = 0.1f;

    //float4 diffusecolor = tex2D(colormap0, input.texcoord);

    //output.color = float4(input.texcoord, 0.0f, 1.0f);
    //output.color = float4(factor, factor, factor, 1.0);
    //output.color = float4(float3(ambient + factor), 1.0);
    //output.color = float4(1.0f, 0.0, 0.0, 1.0);
    output.color = float4(input.AO * (factor + ambient), 1.0);
    //output.color = float4(input.AO, 1.0);
    //output.color = float4((factor+ambient)*0.7f,0.0,0.0,0.0);
    //output.color = float4(0.1f + input.AO.x,0.0,0.0,0.0);
    //output.color = float4(normal, 1.0f);
    //output.color = diffusecolor;

	return output;
}

technique terrain
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader();
		VertexProgram = compile vp40 mvertexshader();
	}
}

