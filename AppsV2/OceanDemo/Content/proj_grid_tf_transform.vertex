#version 150

out vec3 out_position;
out vec3 out_normal;

void main()
{
    vec4 near = vec4(in_position.xy, -1.0, 1.0);
    vec4 far  = vec4(in_position.xy,  1.0, 1.0);

    vec4 rNear = invMVP * near;
    vec4 rFar  = invMVP * far;

    vec3 point = rNear.xyz / rNear.w;
    vec3 direction = (rFar.xyz / rFar.w) - point;

    const vec4 plane = vec4(0.0, 1.0, 0.0, 0.0);
    float point_dot_planenormal = dot(point, plane.xyz);
    float direction_dot_planenormal = dot(direction, plane.xyz);
    float t = ( plane.w - point_dot_planenormal ) / direction_dot_planenormal;
    vec3 intersection = point + t * direction;

    vec2 texcoord = intersection.xz;
    texcoord *= (1.0 / area);

    float h = textureLod(heightmap, texcoord, 0.0).x;
    float ht = textureLodOffset(heightmap, texcoord, 0.0, ivec2(0,  1)).x;
    float hb = textureLodOffset(heightmap, texcoord, 0.0, ivec2(0, -1)).x;
    float hl = textureLodOffset(heightmap, texcoord, 0.0, ivec2(-1, 0)).x;
    float hr = textureLodOffset(heightmap, texcoord, 0.0, ivec2( 1, 0)).x;

    vec4 s  = textureLod(supplemental, texcoord, 0.0);    

    out_position.xz = intersection.xz;
    out_position.x -= s.z;
    out_position.z += s.w;
    out_position.y = h;

    //out_normal = vec3((hr - hl) / -2.0, 1.0, (ht - hb) / -2.0);
    out_normal = vec3(-s.x, 1.0, s.y);

    gl_Position = np_modelviewprojectionmatrix * vec4(intersection, 1.0);
}
