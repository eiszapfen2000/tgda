#version 150

out vec3 out_position;
out vec2 out_non_disp_position;

vec3 world_space_position(in vec2 position)
{
    vec4 near = vec4(position, -1.0, 1.0);
    vec4 far  = vec4(position,  1.0, 1.0);

    vec4 rNear = invMVP * near;
    vec4 rFar  = invMVP * far;

    vec3 point = rNear.xyz / rNear.w;
    vec3 direction = (rFar.xyz / rFar.w) - point;

    const vec4 plane = vec4(0.0, 1.0, 0.0, 0.0);
    float point_dot_planenormal = dot(point, plane.xyz);
    float direction_dot_planenormal = dot(direction, plane.xyz);
    float t = ( plane.w - point_dot_planenormal ) / direction_dot_planenormal;

    vec3 intersection = point + t * direction;

    return intersection;
}

void main()
{
    vec3 intersection = world_space_position(in_position.xy);
    vec3 intersection_dx = world_space_position(in_position.xy + vec2(vertexStep.x, 0.0));
    vec3 intersection_dy = world_space_position(in_position.xy + vec2(0.0, vertexStep.y));
    vec2 d_dx = (abs(intersection_dx.xz - intersection.xz) * 2.0) / area;
    vec2 d_dy = (abs(intersection_dy.xz - intersection.xz) * 2.0) / area;

    vec2 texcoord = intersection.xz;
    texcoord *= (1.0 / area);

    float h = textureGrad(heightmap, texcoord, d_dx, d_dy).x;

    // I do not know if we should scale displacement with
    // areaScale or not. It makes sense regarding correctness
    // but not necessarily for tweaking
    vec2 d = textureGrad(displacement, texcoord, d_dx, d_dy).xy;

    out_non_disp_position = intersection.xz;
    out_position.xz  = intersection.xz - displacementScale * d.xy;
    out_position.y   = h * heightScale;

    gl_Position = np_modelviewprojectionmatrix * vec4(intersection, 1.0);
}
