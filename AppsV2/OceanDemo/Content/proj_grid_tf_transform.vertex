#version 150

out vec3 out_position;
out vec2 out_non_disp_position;

void main()
{
    vec4 near = vec4(in_position.xy, -1.0, 1.0);
    vec4 far  = vec4(in_position.xy,  1.0, 1.0);

    vec4 rNear = invMVP * near;
    vec4 rFar  = invMVP * far;

    vec3 point = rNear.xyz / rNear.w;
    vec3 direction = (rFar.xyz / rFar.w) - point;

    const vec4 plane = vec4(0.0, 1.0, 0.0, 0.0);
    float point_dot_planenormal = dot(point, plane.xyz);
    float direction_dot_planenormal = dot(direction, plane.xyz);
    float t = ( plane.w - point_dot_planenormal ) / direction_dot_planenormal;
    vec3 intersection = point + t * direction;

    vec2 texcoord = intersection.xz;
    texcoord *= (1.0 / area);

    // due to fftw memory layout textures are upside down
    // it does not matter for heights, but displacement as well
    // gradient in z direction have to invert sign

    float h = textureLod(heightmap, texcoord, 0.0).x;

    
    float ht = textureLodOffset(heightmap, texcoord, 0.0, ivec2(0,  1)).x;
    float hb = textureLodOffset(heightmap, texcoord, 0.0, ivec2(0, -1)).x;
    float hl = textureLodOffset(heightmap, texcoord, 0.0, ivec2(-1, 0)).x;
    float hr = textureLodOffset(heightmap, texcoord, 0.0, ivec2( 1, 0)).x;
    
    vec2 d  = textureLod(displacement, texcoord, 0.0).xy;
    vec2 g  = textureLod(gradient, texcoord, 0.0).xy;

    out_non_disp_position = intersection.xz;
    out_position.xz = intersection.xz;
    out_position.x -= displacementScale * d.x;
    out_position.z += displacementScale * d.y;
    out_position.y = h;

    gl_Position = np_modelviewprojectionmatrix * vec4(intersection, 1.0);
}
