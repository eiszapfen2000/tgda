#version 150

in vec3 out_ws_position;

#define MATH_PI 3.14159

float blinn_phong_distribution(vec3 n, vec3 h, float alpha_p)
{
    float specular_normalization = (alpha_p + 2.0) / (2.0 * MATH_PI);
    float n_dot_h = clamp(dot(n, h), 0.0, 1.0);
    float power = pow(n_dot_h, alpha_p);

    return specular_normalization * power;
}

float beckmann_distribution(vec3 n, vec3 h, float m)
{
    float n_dot_h = clamp(dot(n, h), 0.001, 1.0);
    float n_dot_h_square = n_dot_h * n_dot_h;

    float exponent = (n_dot_h_square - 1.0) / (m * m * n_dot_h_square);
    float power = exp(exponent);

    return power / (MATH_PI * m * m * n_dot_h_square * n_dot_h_square);
}

float geometry_implicit(vec3 n, vec3 h, vec3 v, vec3 l)
{
    float n_dot_l = clamp(dot(n, l), 0.0, 1.0);
    float n_dot_v = clamp(dot(n, v), 0.0, 1.0);

    return n_dot_l * n_dot_v;
}

float geometry_cook_torrance(vec3 n, vec3 h, vec3 v, vec3 l)
{
    float n_dot_h = clamp(dot(n, h), 0.001, 1.0);
    float n_dot_v = clamp(dot(n, v), 0.001, 1.0);
    float n_dot_l = clamp(dot(n, l), 0.001, 1.0);
    float v_dot_h = clamp(dot(v, h), 0.001, 1.0);

    float g1 = (2.0 * n_dot_h * n_dot_v) / v_dot_h;
    float g2 = (2.0 * n_dot_h * n_dot_l) / v_dot_h;

    return min(1.0, min(g1, g2));
}

void main()
{
    vec2 cell = mod(abs(out_ws_position.xz), area);

    if ( cell.x < 5.0 || cell.y < 5.0 )
    {
        target = vec4(0.0, 1.0, 0.0, 1.0);
    }
    else
    {
        target = vec4(1.0);
    }
}

