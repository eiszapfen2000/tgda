#version 150

in vec3 out_ws_position;
in vec2 out_ws_non_disp_position;

#define MATH_PI      3.141592653
#define MATH_SQRT_PI 1.772453851

float blinn_phong_distribution(vec3 n, vec3 h, float alpha_p)
{
    float specular_normalization = (alpha_p + 2.0) / (2.0 * MATH_PI);
    float n_dot_h = clamp(dot(n, h), 0.0, 1.0);
    float power = pow(n_dot_h, alpha_p);

    return specular_normalization * power;
}

float beckmann_distribution(vec3 n, vec3 h, float m)
{
    float n_dot_h = clamp(dot(n, h), 0.001, 1.0);
    float n_dot_h_square = n_dot_h * n_dot_h;

    float exponent = (n_dot_h_square - 1.0) / (m * m * n_dot_h_square);
    float power = exp(exponent);

    return power / (MATH_PI * m * m * n_dot_h_square * n_dot_h_square);
}

float geometry_implicit(vec3 n, vec3 h, vec3 v, vec3 l)
{
    float n_dot_l = clamp(dot(n, l), 0.0, 1.0);
    float n_dot_v = clamp(dot(n, v), 0.0, 1.0);

    return n_dot_l * n_dot_v;
}

float geometry_cook_torrance(vec3 n, vec3 h, vec3 v, vec3 l)
{
    float n_dot_h = clamp(dot(n, h), 0.001, 1.0);
    float n_dot_v = clamp(dot(n, v), 0.001, 1.0);
    float n_dot_l = clamp(dot(n, l), 0.001, 1.0);
    float v_dot_h = clamp(dot(v, h), 0.001, 1.0);

    float g1 = (2.0 * n_dot_h * n_dot_v) / v_dot_h;
    float g2 = (2.0 * n_dot_h * n_dot_l) / v_dot_h;

    return min(1.0, min(g1, g2));
}

float erf(float x)
{
    const float a = 0.140012;
    float x_sqr = x * x;
    float a_x_sqr = a * x_sqr;

    float n = (4.0 / MATH_PI) + a_x_sqr;
    float d = 1.0 + a_x_sqr;
    float exponent = -x_sqr * (n / d);

    return clamp(sign(x) * sqrt(1.0 - exp(exponent)), -1.0, 1.0);
}

float erfc(float x)
{
    return clamp(1.0 - erf(x), 0.0, 2.0);
}

float Lambda(float v)
{
    return max(0.0, (exp(-(v * v)) - v * MATH_SQRT_PI * erfc(v)) / (2.0 * v * MATH_SQRT_PI));
}

float p(vec2 sigmaSqr, vec2 zeta)
{
    float x = (zeta.x * zeta.x) / sigmaSqr.x;
    float y = (zeta.y * zeta.y) / sigmaSqr.y;
    float exponent = -0.5 * (x + y);

    return exp(exponent) / (2.0 * MATH_PI * sqrt(sigmaSqr.x * sigmaSqr.y));
}

/*
float Lambda(float cosTheta, float sigmaSq)
{
    float v = cosTheta / sqrt((1.0 - cosTheta * cosTheta) * (2.0 * sigmaSq));

    return max(0.0, (exp(-v * v) - v * sqrt(MATH_PI) * erfc(v)) / (2.0 * v * sqrt(MATH_PI)));
}

// L, V, N, Tx, Ty in world space
float reflectedSunRadiance(vec3 L, vec3 V, vec3 N, vec3 Tx, vec3 Ty, vec2 sigmaSq)
{
    vec3 H = normalize(L + V);
    float zetax = dot(H, Tx) / dot(H, N);
    float zetay = dot(H, Ty) / dot(H, N);

    float zL = dot(L, N); // cos of source zenith angle
    float zV = dot(V, N); // cos of receiver zenith angle
    float zH = dot(H, N); // cos of facet normal zenith angle
    float zH2 = zH * zH;

    float p = exp(-0.5 * (zetax * zetax / sigmaSq.x + zetay * zetay / sigmaSq.y))
                / (2.0 * MATH_PI * sqrt(sigmaSq.x * sigmaSq.y));

    float tanV = atan(dot(V, Ty), dot(V, Tx));
    float cosV2 = 1.0 / (1.0 + tanV * tanV);
    float sigmaV2 = sigmaSq.x * cosV2 + sigmaSq.y * (1.0 - cosV2);

    float tanL = atan(dot(L, Ty), dot(L, Tx));
    float cosL2 = 1.0 / (1.0 + tanL * tanL);
    float sigmaL2 = sigmaSq.x * cosL2 + sigmaSq.y * (1.0 - cosL2);

    float fresnel = 0.02 + 0.98 * pow(1.0 - dot(V, H), 5.0);

    zL = max(zL, 0.01);
    zV = max(zV, 0.01);

    return fresnel * p / ((1.0 + Lambda(zL, sigmaL2) + Lambda(zV, sigmaV2)) * zV * zH2 * zH2 * 4.0);
}
*/

float meanFresnel(float cosThetaV, float sigmaV)
{
    return pow(1.0 - cosThetaV, 5.0 * exp(-2.69 * sigmaV)) / (1.0 + 22.7 * pow(sigmaV, 1.5));
}

// V, N in world space
float meanFresnel(vec3 V, vec3 N, vec2 sigmaSq)
{
    // view direction in wind space
    vec2 v = V.xz;
    // cos^2 and sin^2 of view direction
    vec2 t = v * v / (1.0 - V.y * V.y);
    // slope variance in view direction
    float sigmaV2 = dot(t, sigmaSq);

    return meanFresnel(dot(V, N), sqrt(sigmaV2));
}

void main()
{
    float Jxx = dFdx(out_ws_non_disp_position.x);
    float Jxy = dFdy(out_ws_non_disp_position.x);
    float Jyx = dFdx(out_ws_non_disp_position.y);
    float Jyy = dFdy(out_ws_non_disp_position.y);
    float A = Jxx * Jxx + Jyx * Jyx;
    float B = Jxx * Jxy + Jyx * Jyy;
    float C = Jxy * Jxy + Jyy * Jyy;
    float ua = pow(A, 0.25);
    float ub = 0.5 + 0.5 * B / sqrt(A * C);
    float uc = pow(C, 0.25);

    vec2 sigmaSq = texture(variance, vec3(ua, ub, uc)).xy * 100.0;
    sigmaSq = max(sigmaSq, 2e-5);

    vec2 texcoord = out_ws_non_disp_position;
    texcoord *= (1.0 / area);

    vec2 grad = textureLod(gradient, texcoord, 0.0).xy;
    vec3 normal = vec3(-grad.x, 1.0, grad.y);

    vec3 lightDir = vec3(-1.0, 1.0, 0.0);
    vec3 viewDir  = cameraPosition - out_ws_position;
    vec3 l        = normalize(lightDir);
    vec3 v        = normalize(viewDir);
    //vec3 n        = normalize(out_normal);
    vec3 n        = normalize(normal);
    vec3 h        = normalize(v + l);
    vec3 r        = 2.0 * dot(l, n) * n - l;

    vec3 c_light = vec3(1.0, 1.0, 1.0);
    vec3 c_diff  = vec3(0.0, 0.15, 0.25);
    vec3 c_spec  = vec3(0.02);

    vec3 tx = normalize(vec3(1.0, grad.x, 0.0));
    vec3 ty = normalize(vec3(0.0, -grad.y, 1.0));

    mat3 ross = mat3(ty, n, tx);
    mat3 iross = inverse(ross);

    // target space
    // tx = +z
    // ty = +x
    // n  = +y

    vec3 tx_ross = vec3(0.0, 0.0, 1.0);
    vec3 ty_ross = vec3(1.0, 0.0, 0.0);
    vec3 n_ross  = vec3(0.0, 1.0, 0.0);

    vec3 l_ross = iross * l;
    vec3 v_ross = iross * v;

    vec3 l_ross_planar = normalize(vec3(l_ross.x, 0.0, l_ross.z));
    vec3 v_ross_planar = normalize(vec3(v_ross.x, 0.0, v_ross.z));

    float l_ross_cos_phi = dot(l_ross_planar, tx_ross);
    float v_ross_cos_phi = dot(v_ross_planar, tx_ross);

    float l_ross_cos_phi_square = l_ross_cos_phi * l_ross_cos_phi;
    float v_ross_cos_phi_square = v_ross_cos_phi * v_ross_cos_phi;

    float l_sigma_square = sigmaSq.x * l_ross_cos_phi_square + sigmaSq.y * (1.0 - l_ross_cos_phi_square);
    float v_sigma_square = sigmaSq.x * v_ross_cos_phi_square + sigmaSq.y * (1.0 - v_ross_cos_phi_square);

    float l_ross_cos_theta = dot(l_ross, n_ross);
    float v_ross_cos_theta = dot(v_ross, n_ross);

    float l_ross_cos_theta_square = l_ross_cos_theta * l_ross_cos_theta;
    float v_ross_cos_theta_square = v_ross_cos_theta * v_ross_cos_theta;

    float l_ross_cot_theta = sqrt(l_ross_cos_theta_square / (1.0 - l_ross_cos_theta_square));
    float v_ross_cot_theta = sqrt(v_ross_cos_theta_square / (1.0 - v_ross_cos_theta_square));

    float l_v = l_ross_cot_theta / sqrt( 2.0 * l_sigma_square);
    float v_v = v_ross_cot_theta / sqrt( 2.0 * v_sigma_square);



    target = vec4(iross * n, 1.0);
}

