#version 150

in vec2 out_texcoords;

#define FLT_MAX 3.40282347e+38F

vec4 ray_intersect(in sampler2D heightMap, in vec2 heightMinMax, in vec4 dpds, in int numberOfLinearSteps)
{
    // start at top
    float depth = heightMinMax.y;
    // assume bottom is best
    float bestDepth = heightMinMax.x;
    // compute depth delta to take each iteration
    float depthStep = (heightMinMax.x - heightMinMax.y) / float(numberOfLinearSteps - 1);
    //
    float lastSampledHeight = depth;
    float currentSampledHeight = depth;
    vec2 lastOffset = vec2(0.0);
    vec2 currentOffset = vec2(0.0);
    int currentNumberOfSteps = 0;

    // search from top to bottom for first point inside the heightfield
    while ( currentNumberOfSteps < numberOfLinearSteps )
    {
        currentSampledHeight = textureLod(heightMap, dpds.xy + currentOffset, 0).r;

        if ( currentSampledHeight > depth )
        {
            bestDepth = depth;
            currentNumberOfSteps = numberOfLinearSteps + 1;
            
			float delta1 = currentSampledHeight - depth;
			float delta2 = ( depth - depthStep ) - lastSampledHeight;
			float ratio = delta1 / ( delta1 + delta2 );
            
			currentOffset = (ratio * lastOffset) + ((1.0-ratio) * currentOffset);
        }
        else
        {
            depth += depthStep;
            lastSampledHeight = currentSampledHeight;
            lastOffset = currentOffset;
            currentOffset = float(currentNumberOfSteps) * dpds.zw;
            currentNumberOfSteps++;
        }
    }

    vec4 result = vec4(0.0);
    result.w = textureLod(heightMap, dpds.xy + currentOffset, 0).r;

    float gx = textureLod(gradientX, dpds.xy + currentOffset, 0).r;
    float gz = textureLod(gradientZ, dpds.xy + currentOffset, 0).r;
    result.xyz = normalize(vec3(-gx, 1.0, -gz));

    return result;
}

void main()
{
    vec4 position = textureLod(positions, out_texcoords.xy, 0);
    vec4 normal   = textureLod(normals,   out_texcoords.xy, 0);

    // no position data
    if (position == vec4(FLT_MAX))
    {
        target = vec4(1.0, 0.0, 0.0, 1.0);
    }
    else
    {
        const float waterLevel = 0.0;
        vec4 color = vec4(1.0);

        if (position.y <= (waterLevel + heightfieldMinMax.y))
        {
            const vec3 planeNormal = vec3(0.0, 1.0, 0.0);
            const int numberOfLinearSteps = 16;
            const float tileSizeInWS = 50.0;

            vec3 rayDirection = position.xyz - cameraPosition.xyz;
            float d1 = dot(cameraPosition, planeNormal);
            float d2 = dot(rayDirection, planeNormal);

            float t0 = (waterLevel - d1) / d2;
            float tBottom = (heightfieldMinMax.x - d1) / d2;
            float tTop = (heightfieldMinMax.y - d1) / d2;

            vec3 topPoint = cameraPosition + tTop * rayDirection;
            vec3 bottomPoint = cameraPosition + tBottom * rayDirection;
            vec3 point = cameraPosition + t0 * rayDirection;

            vec4 dpds;
            dpds.xy = (topPoint.xz / tileSizeInWS);
            dpds.zw = ((bottomPoint.xz - topPoint.xz) / tileSizeInWS);
            dpds.zw = dpds.zw / float(numberOfLinearSteps - 1);

            vec4 lala = ray_intersect(heightfield, heightfieldMinMax, dpds, numberOfLinearSteps);

            if (t0 < 0.0)
            {
                color = vec4(0.0, 1.0, 0.0, 1.0);
            }
            else
            {
                color = vec4(0.0, 0.0, (lala.x - heightfieldMinMax.x) / (heightfieldMinMax.y - heightfieldMinMax.x), 1.0);
                //vec3 snormal = normalize(vec3(0.0, 1.0, -1.0));
                //float diffuse = max(dot(snormal, lala.xyz), 0.0);
                //color = vec4(diffuse, diffuse, diffuse, 1.0);
            }
            

            //color = vec4(0.0, 0.0, rtes, 1.0);
            
            /*
            if (tBottom > tTop)
                color = vec4(0.0, 1.0, 0.0, 1.0);
            else
                color = vec4(0.0, 0.0, 1.0, 1.0);
            */

        }

        target = color;
    }
}

