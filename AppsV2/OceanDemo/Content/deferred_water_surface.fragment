#version 150

in vec2 out_texcoords;

#define FLT_MAX 3.40282347e+38F

float ray_intersect(in sampler2D heightMap, in vec2 heightMinMax, in vec4 dpds, in int numberOfLinearSteps)
{
    // start at top
    float depth = heightMinMax.y;
    // assume bottom is best
    float bestDepth = heightMinMax.x;
    // compute depth delta to take each iteration
    float depthStep = (heightMinMax.x - heightMinMax.y) / float(numberOfLinearSteps - 1);

    // search from top to bottom for first point inside the heightfield
    for (int i = 0; i < numberOfLinearSteps; i++)
    {
        vec4 h = textureLod(heightMap, dpds.xy + float(i) * dpds.zw, 0);

        if ( depth <= h.x )
        {
            bestDepth = depth;
            break;
        }         

        depth += depthStep;
    }

    return bestDepth;
}

void main()
{
    vec4 position = textureLod(positions, out_texcoords.xy, 0);
    vec4 normal   = textureLod(normals,   out_texcoords.xy, 0);

    // no position data
    if (position == vec4(FLT_MAX))
    {
        target = vec4(1.0, 0.0, 0.0, 1.0);
    }
    else
    {
        const float waterLevel = 0.0;
        vec4 color = vec4(1.0);

        if (position.y <= (waterLevel + heightfieldMinMax.y))
        {
            const vec3 planeNormal = vec3(0.0, 1.0, 0.0);
            const int numberOfLinearSteps = 10;
            const float tileSizeInWS = 20.0;

            vec3 rayDirection = position.xyz - cameraPosition.xyz;
            float d1 = dot(cameraPosition, planeNormal);
            float d2 = dot(rayDirection, planeNormal);

            float t0 = (waterLevel - d1) / d2;
            float tBottom = (heightfieldMinMax.x - d1) / d2;
            float tTop = (heightfieldMinMax.y - d1) / d2;

            vec3 topPoint = cameraPosition + tTop * rayDirection;
            vec3 bottomPoint = cameraPosition + tBottom * rayDirection;
            vec3 point = cameraPosition + t0 * rayDirection;

            vec3 ray = bottomPoint - topPoint;
            vec2 rayOnPlane = ray.xz;

            vec4 dpds;
            dpds.xy = (topPoint.xz / tileSizeInWS);
            dpds.zw = ((bottomPoint.xz - topPoint.xz) / tileSizeInWS);
            dpds.zw = dpds.zw / float(numberOfLinearSteps - 1);

            float lala = ray_intersect(heightfield, heightfieldMinMax, dpds, int(10));

            if (t0 < 0.0)
                color = vec4(0.0, 1.0, 0.0, 1.0);
            else
                color = vec4(0.0, 0.0, lala + 1.0, 1.0);
            

            //color = vec4(0.0, 0.0, rtes, 1.0);
            
            /*
            if (tBottom > tTop)
                color = vec4(0.0, 1.0, 0.0, 1.0);
            else
                color = vec4(0.0, 0.0, 1.0, 1.0);
            */

        }

        target = color;
    }
}

