\chapter{Implementation}
\label{ch:implementation}

\section{The Projected Grid}
\label{sec_projected_grid}
The projected grid is based on a simple concept: in order to achieve an
uniform distribution of details on the image plane, a uniformly spaced grid is
created in post-perspective space and transformed back to world space.
Figure~\ref{fig:projectedgrid} illustrates the difference between a classic
world space approach and the projected grid.
\begin{figure}[h]
\centering
\subbottom[Classic]
{
\includegraphics[scale=0.75]{figures/ProjectedGridVsWorldSpace.pdf}
\label{fig:subfigprojgrid1}
}
\subbottom[Projected Grid]
{
\includegraphics[scale=0.75]{figures/ProjectedGridUniform.pdf}
\label{fig:subfigprojgrid2}
}
\caption{The image on the left shows an uniform grid in worldspace,
its projection onto the image plane is not uniformly spaced though.
The image on the right on the other hand depicts an uniform grid on
the image plane and its associated non-uniform spaced worldspace
positions.}
\label{fig:projectedgrid}
\end{figure}

% The algorithm used for the projected grid can be broken down into the following
% steps:
% \begin{itemize}
%  \item create a uniformly spaced grid orthogonal to the viewer using normalised
% device coordinates
%  \item transform the grid to worldspace
%  \item project the grid onto the desired base plane
%  \item apply height displacement
%  \item run the grid through the rendering pipeline as usual
% \end{itemize}

\subsection{Coordinate Systems}
\label{sec:coordinate_systems}
Let $\mvec{x}$ be a vector representing the three dimensional carthesian
world space coordinate of a vertex, then
\begin{equation}
 \mvec{w} = \transpose{(\mvecx{x}, \mvecy{x}, \mvecz{x}, 1)}
\end{equation}
where $\mvec{w}$ is a homogeneous world space coordinate of $\mvec{x}$.
Let $\mmat{V}$ be the view matrix and $\mmat{P}$ the projection matrix, then
\begin{equation}
\label{eq:ws_to_cs}
 \mvec{c} = \mmat{P} \mmat{V} \mvec{w}
\end{equation}
where $\mvec{c}$ is the \textit{clip space} coordinate of $\mvec{w}$. For $\mvec{c}$ to
be inside the view frustum defined by $\mmat{P}$, $\mvec{c}$ is required to
meet the following condition
\begin{equation}
\label{eq:cs_bounds}
 \mvecx{c}, \mvecy{c}, \mvecz{c} \in \interval{-\mvecw{c}}{\mvecw{c}}
\end{equation}
where $\mvecw{c}$ is the homogeneous component of $\mvec{c}$. Next, clip space
vertex $\mvec{c}$ is transformed by the \textit{perspective division} as follows
\begin{equation}
\label{eq:cs_to_ndc}
 \mvec{n} = \frac{1}{\mvecw{c}}\transpose{(\mvecx{c}, \mvecy{c}, \mvecz{c})}
\end{equation}
where $\mvec{n}$ corresponds to the \textit{normalised device coordinate},
\textit{NDC} in short, of $\mvec{c}$.
%
%
\begin{figure}
\centering
\subbottom[View Frustum]
{
\includegraphics[width=0.4\textwidth]{figures/ProjectiveFrustum.pdf}
\label{fig:subfig_proj_frustum}
}
\subbottom[Canonical view volume]
{
\includegraphics[width=0.4\textwidth]{figures/CanonicalCube.pdf}
\label{fig:subfig_canonical_view_volume}
}
\caption{Left: An example view frustum in view space. Right: The same view frustum
after applying projection and perspective division.}
\label{fig:proj_frustum_ndc}
\end{figure}
%
%
As one can see, equations~\ref{eq:cs_bounds}
and~\ref{eq:cs_to_ndc} imply
\begin{equation}
\label{eq:ndc_bounds}
 \mvecx{n}, \mvecy{n}, \mvecz{n} \in \interval{-1}{1}
\end{equation}
which defines the space NDC reside in, namely the \textit{canonical view volume},
see Figure~\ref{fig:proj_frustum_ndc}.\\


The projected grid, on the other hand, starts inside the canonical view volume
and needs to transform vertices back to world space. Let $\mvec{n}$ be the
normalised device coordinate of a vertex, then
\begin{equation}
\label{eq:ndc_to_cs}
 \mvec{c} = \transpose{(\mvecx{n}, \mvecy{n}, \mvecz{n}, 1)}
\end{equation}
where $\mvec{c}$ is a valid representation of $\mvec{n}$ in clip space. One may choose
a value for $\mvecw{c}$ different from $1$, making it necessary to scale $\mvecx{n}$,
$\mvecy{n}$ and $\mvecz{n}$ accordingly. Again, let $\mmat{V}$ be the view matrix and
$\mmat{P}$ the projection matrix, then
\begin{equation}
\label{eq:cs_to_wsh}
 \mvec{w} = \inverse{(\mmat{P} \mmat{V})} \mvec{c}
\end{equation}
where $\mvec{w}$ is a homogeneous world space coordinate of $\mvec{c}$. Conversion
to three dimensional carthesian world space is accomplished as follows
\begin{equation}
\label{eq:wsh_to_ws}
 \mvec{x} = \frac{1}{\mvecw{w}}\transpose{(\mvecx{w}, \mvecy{w}, \mvecz{w})}
\end{equation}

\subsection{Projection onto Plane}
As noted before, the vertices of the projected grid are represented as normalised
device coordinates. Assuming the plane the grid shall be projected on is specified
in world space coordinates, the following steps need to be computed for each vertex:
\begin{itemize}
 \item Transform vertex from canonical view volume to world space
 \item Setup vertex specific ray
 \item Intersect ray with target plane to compute actual position
\end{itemize}
Step one is already covered by Section~\ref{sec:coordinate_systems}. Step two
requires to setup a ray for each vertex, which implies both a position and a
direction. The position we already have, but to create a direction we need two
different positions. The solution is rather straightforward: let $\mvec{n}$ be
a \textit{two dimensional} vector representing the \textit{X} and \textit{Y}
components of a position in normalised device coordinates, then
\begin{align}
 \mvec{a} & = (\mvecx{n}, \mvecy{n}, -1, 1)\\
 \mvec{b} & = (\mvecx{n}, \mvecy{n}, +1, 1)
\end{align}
where $\mvec{a}$ corresponds to $\mvec{n}$ on the \textit{near plane} in clip space,
and $\mvec{b}$ to $\mvec{n}$ on the \textit{far plane} in clip space. Let $\mvec{d}$
and $\mvec{e}$ be the carthesian world space positions of $\mvec{a}$ and $\mvec{b}$
respectively, then
\begin{equation}
 \label{eq:proj_grid_ray}
 \mvec{p} = \mvec{d} + t(\mvec{e} - \mvec{d})
\end{equation}
where $\mvec{p}$ represents a ray starting at point $\mvec{d}$, pointing in direction
$(\mvec{e} - \mvec{d})$ with variable parameter $t$ controlling the actual position on
the ray.\\

Step three is about intersecting ray $\mvec{p}$ resulting from step two with the target plane.
We define the target plane using the \textit{Hesse normal form} as follows
\begin{equation}
\label{eq:proj_grid_plane}
 \mvec{p}\transpose{\mvec{n}} - d = 0
\end{equation}
where $\mvec{n}$ is the plane's normal vector with unit length and $d$ the plane's distance
from the origin. Next, we insert $\mvec{p}$ from equation~\ref{eq:proj_grid_ray}
into equation~\ref{eq:proj_grid_plane}, resulting in
%
\begin{gather}
\label{eq:plane_and_ray_intersection}
(\mvec{d} + t(\mvec{e} - \mvec{d})\transpose{\mvec{n}} - d = 0\\
\mvec{d}\transpose{\mvec{n}} + t(\mvec{e} - \mvec{d})\transpose{\mvec{n}} - d = 0\\
\intertext{solve for $t$}
t = \cfrac{d - \mvec{d}\transpose{\mvec{n}}}{(\mvec{e} - \mvec{d})\transpose{\mvec{n}}}
\end{gather}
%
where $t$ in combination with equation~\ref{eq:proj_grid_ray} gives the point of intersection
between the ray and the plane. In case $(\mvec{e} - \mvec{d})\transpose{\mvec{n}} = 0$,
there is no point of intersection because the ray is parallel to the plane.

\subsection{Projector}
\fxnote*{JÃ–SSAS}{Backfiring, etc}

\section{Discrete Fourier Transform}
We defined surface elevation as follows in Chapter~\ref{sec:random_amplitudes}:
\begin{equation}
\label{eq:dft_surface_elevation}
\eta(\mvec{x}, t) = 
\sum_{\mvec{k}}\frac{1}{\sqrt{2}}(\xi_r+\mathrm{i}\xi_i)
\sqrt{2\Theta(\mvec{k})\Delta k_x \Delta k_y} 
~\mathrm{e}^{-\mathrm{i}\omega(\mvec{k})t}
~\mathrm{e}^{\mathrm{i}\transpose{\mvec{k}}\mvec{x}}
\end{equation}
where both the spatial domain $\mvec{x}$ and the wavevector domain $\mvec{k}$ are
of resolution $N \times N$. $N$ is a natural number, even, and a power of two.
The latter two requirements are concessions to the~\emph{Fast Fourier Transform}
algorithm, which works fastest at such resolutions. We may define the following
two terms based on Equation~\ref{eq:dft_surface_elevation}:
\begin{align}
\label{eq:dft_h0_k}
h_0(\mvec{k})   &= \frac{1}{\sqrt{2}}(\xi_r+\mathrm{i}\xi_i)\sqrt{2\Theta(\mvec{k})\Delta k_x \Delta k_y} \\
\label{eq:dft_h0_k_t}
h_0(\mvec{k},t) &= h_0(\mvec{k})~\mathrm{e}^{-\mathrm{i}\omega(\mvec{k})t}
\end{align}
The term $h_0(\mvec{k})$ represents a random generated spectrum based on wave
spectrum $\Theta(\mvec{k})$. The term $h_0(\mvec{k},t)$ takes care of the
animation over time of $h_0(\mvec{k})$. As long as the spatial domain,
the wavevector domain, and the wave spectrum do not change, $h_0(\mvec{k})$
does not change either. Hence, it is necessary to generate $h_0(\mvec{k})$ only once
for a specific set of parameters such as area, resolution, wind and fetch. Thus,
only the exponential responsible for the animation has to be computed for all
frames.
%
\subsubsection{Zero Frequency}
%
\newcommand{\ccellnum}[2]{\cellcolor{#1}\num{#2}}
\newcommand{\mcleft}[2]{\multicolumn{1}{!{\color{#1}\vline}S}{#2}}
\newcommand{\mcright}[2]{\multicolumn{1}{S !{\color{#1}\vline}}{#2}}
\newcommand{\mcleftright}[2]{\multicolumn{1}{!{\color{#1}\vline} S !{\color{#1}\vline}}{#2}}
\colorlet{Q1Color}{cyan!25}
\colorlet{Q2Color}{NavyBlue!50}
\colorlet{Q3Color}{violet!45}
\colorlet{Q4Color}{white}
\colorlet{Line1Color}{blue}
\colorlet{Line2Color}{black}
%
We compute surface elevation in the form of an inverse Discrete Fourier Transform as follows:
\begin{align}
\label{eq:surface_elevation_h0_k_t}
\eta(\mvec{x}, t) = \sum_{\mvec{k}}~h_0(\mvec{k},t)~\mathrm{e}^{\mathrm{i}\transpose{\mvec{k}}\mvec{x}} \\
\intertext{with}
\notag \mvec{k} = (x,y)\in\{(\alpha\Delta k,\beta\Delta k)|
-\frac{N}{2}\leq\alpha,\beta<\frac{N}{2}\} &&
\Delta k = \frac{2\pi}{L}&
\end{align}
As one can see, the wavevector $\mvec{k} = (0,0)$ lies at the center of the wavevector domain,
where $\alpha=0$ and $\beta=0$. But actual implementations of the inverse Discrete Fourier Transform
expect the zero wavevector as the first element i.e. at the upper left. The wavevector domain
of such implementations is defined as follows:
\begin{equation*}
\mvec{k} = (x,y)\in\{(\alpha\Delta k,\beta\Delta k)|
0\leq\alpha,\beta<N-1\}
\end{equation*}
We know that the spectrum represents a periodic signal, i.e. it repeats itself at infinity in both directions.
Hence, independent of where the zero frequency is located inside the wavevector domain, we may write:
\begin{align*}
 h_0(\mvec{k}(\alpha\Delta k,\beta\Delta k)) &\equiv h_0(\mvec{k}((\alpha\pm N)\Delta k, \beta\Delta k) \\
					     &\equiv h_0(\mvec{k}(\alpha\Delta k, (\beta\pm N)\Delta k) \\
					     &\equiv h_0(\mvec{k}((\alpha\pm N)\Delta k, (\beta\pm N)\Delta k)
\end{align*}
%
\begin{table}
\footnotesize
\centering
%
\sisetup{
round-mode      = places,
round-precision = 1,
explicit-sign = +,
table-number-alignment=right
}
\setlength{\arrayrulewidth}{2pt}
\setlength{\tabcolsep}{3pt}
%
\begin{tabular}{SSSSSSSS}
\hhline{>{\arrayrulecolor{Line1Color}}*{4}{-}~~}
%
\mcleft{Line1Color}{\ccellnum{Q1Color}{1.36+0.00i}} & \ccellnum{Q1Color}{-1.34+1.24i} & \ccellnum{Q2Color}{-1.04+0.00i} & \mcright{Line1Color}{\ccellnum{Q2Color}{-1.34-1.24i}} & \ccellnum{Q1Color}{1.36+0.00i} & \ccellnum{Q1Color}{-1.34+1.24i} & \ccellnum{Q2Color}{-1.04+0.00i} & \ccellnum{Q2Color}{-1.34-1.24i} \\
\mcleft{Line1Color}{\ccellnum{Q1Color}{0.67-0.65i}} & \ccellnum{Q1Color}{ 0.07+0.37i} & \ccellnum{Q2Color}{ 0.87+0.03i} & \mcright{Line1Color}{\ccellnum{Q2Color}{ 0.71+0.21i}} & \ccellnum{Q1Color}{0.67-0.65i} & \ccellnum{Q1Color}{ 0.07+0.37i} & \ccellnum{Q2Color}{ 0.87+0.03i} & \ccellnum{Q2Color}{ 0.71+0.21i} \\
%
\hhline{>{\arrayrulecolor{Line1Color}}|>{\arrayrulecolor{Q1Color}}-->{\arrayrulecolor{Line2Color}}*{4}{-}>{\arrayrulecolor{Q2Color}}--}
%
\mcleft{Line1Color}{\ccellnum{Q3Color}{1.62+0.00i}} & \ccellnum{Q3Color}{0.04+0.16i} & \mcleft{Line2Color}{\textcolor{red}{\num{9.62+0.0i}}} & \mcright{Line1Color}{\num{0.04-0.16i}} & \ccellnum{Q3Color}{1.62+0.0i} & \mcright{Line2Color}{\ccellnum{Q3Color}{0.04+0.16i}}  & \textcolor{red}{\num{9.62+0.0i}} & \num{0.04-0.16i} \\
\mcleft{Line1Color}{\ccellnum{Q3Color}{0.67+0.65i}} & \ccellnum{Q3Color}{0.71-0.21i} & \mcleft{Line2Color}{                \num{0.87-0.03i}} & \mcright{Line1Color}{\num{0.07-0.37i}} & \ccellnum{Q3Color}{0.67+0.65i} & \mcright{Line2Color}{\ccellnum{Q3Color}{0.71-0.21i}} &                 \num{0.87-0.03i} & \num{0.07-0.37i} \\
%
\hhline{>{\arrayrulecolor{Line1Color}}*{4}{-}>{\arrayrulecolor{Q3Color}}-->{\arrayrulecolor{Line2Color}}|}
%
\ccellnum{Q1Color}{1.36+0.00i} & \ccellnum{Q1Color}{-1.34+1.24i} & \mcleft{Line2Color}{\ccellnum{Q2Color}{-1.04+0.00i}} & \ccellnum{Q2Color}{-1.34-1.24i} & \ccellnum{Q1Color}{1.36+0.00i} & \mcright{Line2Color}{\ccellnum{Q1Color}{-1.34+1.24i}} & \ccellnum{Q2Color}{-1.04+0.00i} & \ccellnum{Q2Color}{-1.34-1.24i} \\
\ccellnum{Q1Color}{0.67-0.65i} & \ccellnum{Q1Color}{ 0.07+0.37i} & \mcleft{Line2Color}{\ccellnum{Q2Color}{ 0.87+0.03i}} & \ccellnum{Q2Color}{ 0.71+0.21i} & \ccellnum{Q1Color}{0.67-0.65i} & \mcright{Line2Color}{\ccellnum{Q1Color}{ 0.07+0.37i}}  & \ccellnum{Q2Color}{ 0.87+0.03i} & \ccellnum{Q2Color}{ 0.71+0.21i} \\
%
\hhline{>{\arrayrulecolor{Q1Color}}-->{\arrayrulecolor{Line2Color}}*{4}{-}>{\arrayrulecolor{Q2Color}}--}
{\ccellnum{Q3Color}{1.62+0.00i}} & \ccellnum{Q3Color}{0.04+0.16i} & {\textcolor{red}{\num{9.62+0.0i}}} & {\num{0.04-0.16i}} & \ccellnum{Q3Color}{1.62+0.0i}  & {\ccellnum{Q3Color}{0.04+0.16i}}  & \textcolor{red}{\num{9.62+0.0i}} & \num{0.04-0.16i} \\
{\ccellnum{Q3Color}{0.67+0.65i}} & \ccellnum{Q3Color}{0.71-0.21i} & {                \num{0.87-0.03i}} & {\num{0.07-0.37i}} & \ccellnum{Q3Color}{0.67+0.65i} & {\ccellnum{Q3Color}{0.71-0.21i}} &                  \num{0.87-0.03i} & \num{0.07-0.37i} \\

\end{tabular}
\caption{Example spectrum ($N = 4$) which consists of four colour-coded quadrants, the zero frequency is in red.
The spectrum repeats itself towards the right and the bottom. Blue frame: spectrum where the zero frequency
is at the center of the wavevector domain. Black frame: spectrum where the zero frequency is at the
upper left of the wavevector domain.}
\label{tab:spectrum_q_repeat}
\end{table}
%
\newsubfloat{table}
\begin{table}
\footnotesize
\setlength{\tabcolsep}{3pt}
\sisetup{
round-mode      = places,
round-precision = 1,
explicit-sign = +,
table-number-alignment=right
}
\subbottom[Zero frequency at the center.]{%
\begin{tabular}{|SSSS|}
\hline
{\ccellnum{Q1Color}{1.36+0.00i}} & \ccellnum{Q1Color}{-1.34+1.24i} & \ccellnum{Q2Color}{-1.04+0.00i} & {\ccellnum{Q2Color}{-1.34-1.24i}} \\
{\ccellnum{Q1Color}{0.67-0.65i}} & \ccellnum{Q1Color}{ 0.07+0.37i} & \ccellnum{Q2Color}{ 0.87+0.03i} & {\ccellnum{Q2Color}{ 0.71+0.21i}} \\
{\ccellnum{Q3Color}{1.62+0.00i}} & \ccellnum{Q3Color}{0.04+0.16i}  & {\textcolor{red}{\num{9.62+0.0i}}} & {\num{0.04-0.16i}} \\
{\ccellnum{Q3Color}{0.67+0.65i}} & \ccellnum{Q3Color}{0.71-0.21i}  & {                \num{0.87-0.03i}} & {\num{0.07-0.37i}} \\
\hline
\end{tabular}
}
\subbottom[Zero frequency at the upper left.]{%
\begin{tabular}{|SSSS|}
\hline
{\textcolor{red}{\num{9.62+0.0i}}} & {\num{0.04-0.16i}} & {\ccellnum{Q3Color}{1.62+0.00i}} & \ccellnum{Q3Color}{0.04+0.16i} \\
{                \num{0.87-0.03i}} & {\num{0.07-0.37i}} & {\ccellnum{Q3Color}{0.67+0.65i}} & \ccellnum{Q3Color}{0.71-0.21i} \\
{\ccellnum{Q2Color}{-1.04+0.00i}}  & {\ccellnum{Q2Color}{-1.34-1.24i}} & {\ccellnum{Q1Color}{1.36+0.00i}} & \ccellnum{Q1Color}{-1.34+1.24i} \\
{\ccellnum{Q2Color}{ 0.87+0.03i}}  & {\ccellnum{Q2Color}{ 0.71+0.21i}} & {\ccellnum{Q1Color}{0.67-0.65i}} & \ccellnum{Q1Color}{ 0.07+0.37i} \\
\hline
\end{tabular}
}
\caption{Swap quadrants diagonally to convert between the two wavevector domains of interest.}
\label{tab:quadrant_swap}
\end{table}
%
Table~\ref{tab:spectrum_q_repeat} depicts such a periodic spectrum, where each instance
of the spectrum is divided into four quadrants. The spectrum always consists of those
four quadrants, independent of where the wavevector domain may begin or end. It is only
the~\emph{layout} of the four quadrants that changes with the wavevector domain.
Table~\ref{tab:quadrant_swap} shows that the conversion from a layout
where the zero frequency is at the center to a layout where the zero
frequency is at the upper left is accomplished by a swap between
diagonally opposite quadrants.

\subsubsection{Symmetry}
%
\colorlet{BorderColor}{gray!10}
\colorlet{CenterColor}{white}
\colorlet{Brak}{blue!25}
%
%
\begin{table}
\footnotesize
\centering
%
\sisetup{
round-mode      = places,
round-precision = 1,
explicit-sign = +,
table-number-alignment=right
}
\setlength{\arrayrulewidth}{.5pt}
\setlength{\tabcolsep}{3pt}
\subbottom{%
\begin{tabular}{SSSS}
\textcolor{gray!50}{\ccellnum{BorderColor}{1.36+0.00i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{-1.34+1.24i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{-1.04+0.00i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{-1.34-1.24i}} \\
\hhline{>{\arrayrulecolor{BorderColor}}->{\arrayrulecolor{black}}*{3}{-}}
\textcolor{gray!50}{\ccellnum{BorderColor}{0.67-0.65i}} & \mcleft{black}{\ccellnum{CenterColor}{0.07+0.37i}} & {\ccellnum{CenterColor}{0.87+0.03i}}                & \mcright{black}{\ccellnum{CenterColor}{0.71+0.21i}} \\
\textcolor{gray!50}{\ccellnum{BorderColor}{1.62+0.00i}} & \mcleft{black}{\ccellnum{CenterColor}{0.04+0.16i}} & \textcolor{red}{\ccellnum{CenterColor}{9.62+0.0i }} & \mcright{black}{\ccellnum{CenterColor}{0.04-0.16i}} \\
\textcolor{gray!50}{\ccellnum{BorderColor}{0.67+0.65i}} & \mcleft{black}{\ccellnum{CenterColor}{0.71-0.21i}} & {\ccellnum{CenterColor}{0.87-0.03i}}                & \mcright{black}{\ccellnum{CenterColor}{0.07-0.37i}} \\
\hhline{>{\arrayrulecolor{BorderColor}}->{\arrayrulecolor{black}}*{3}{-}}
\end{tabular}
}
\subbottom{%
\begin{tabular}{SSSS}
\textcolor{gray!50}{\ccellnum{BorderColor}{1.36+0.00i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{-1.34+1.24i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{-1.04+0.00i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{-1.34-1.24i}} \\
\hhline{>{\arrayrulecolor{BorderColor}}->{\arrayrulecolor{black}}*{3}{-}}
\textcolor{gray!50}{\ccellnum{BorderColor}{0.67-0.65i}} & \mcleft{black}{\ccellnum{blue!20}  { 0.07+0.37i}} & {\ccellnum{violet!60}{0.87+0.03i}}                  & \mcright{black}{\ccellnum{violet!20}{0.71+0.21i}} \\
\textcolor{gray!50}{\ccellnum{BorderColor}{1.62+0.00i}} & \mcleft{black}{\ccellnum{blue!60}  { 0.04+0.16i}} & \textcolor{red}{\ccellnum{CenterColor}{9.62+0.0i }} & \mcright{black}{\ccellnum{blue!60}  {0.04-0.16i}} \\
\textcolor{gray!50}{\ccellnum{BorderColor}{0.67+0.65i}} & \mcleft{black}{\ccellnum{violet!20}{ 0.71-0.21i}} & {\ccellnum{violet!60}{0.87-0.03i}}                  & \mcright{black}{\ccellnum{blue!20}  {0.07-0.37i}} \\
\hhline{>{\arrayrulecolor{BorderColor}}->{\arrayrulecolor{black}}*{3}{-}}
\end{tabular}
}
\caption{Left: The spectrum $\mathcal{F}(\mvec{k})$ of an even-sized ($N = 4$) and real-valued function $f(\mvec{x})$.
The zero frequency $\mvec{k} = (0,0)$ is at the center, written in red.
Right: The matching pairs $\mathcal{F}(-\mvec{k})=\mathcal{F}(\mvec{k})^*$ of the spectrum are colour-coded. One may notice
that the cells in the top row and in the first column to the left lack such pairing.}
\label{tab:spectrum_k_minusk}
\end{table}
%
%
\begin{table}
\footnotesize
%
\sisetup{
round-mode      = places,
round-precision = 1,
explicit-sign = +,
table-number-alignment=right
}
\setlength{\arrayrulewidth}{.5pt}
\setlength{\tabcolsep}{3pt}
\subbottom{%
\begin{tabular}{S|SSS}
{\ccellnum{CenterColor}{1.36+0.00i}} & {\ccellnum{blue!20}{-1.34+1.24i}}                       & \ccellnum{CenterColor}{-1.04+0.00i}                     & {\ccellnum{blue!20}{-1.34-1.24i}} \\
\hline
{\ccellnum{violet!20}{0.67-0.65i}}   & \textcolor{gray!50}{\ccellnum{BorderColor}{0.07+0.37i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.87+0.03i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.71+0.21i}} \\
{\ccellnum{CenterColor}{1.62+0.00i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.04+0.16i}} & \textcolor{red!50} {\ccellnum{BorderColor}{9.62+0.0i }} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.04-0.16i}} \\
{\ccellnum{violet!20}{0.67+0.65i}}   & \textcolor{gray!50}{\ccellnum{BorderColor}{0.71-0.21i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.87-0.03i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.07-0.37i}} \\
\multicolumn{1}{S}{}                 &                                                         &                                                         &                                                         \\
\end{tabular}
}
\subbottom{%
\begin{tabular}{S|SSS|S}
{\ccellnum{red!40}{1.36+0.00i}}    & {\ccellnum{blue!20}{-1.34+1.24i}}                       & \ccellnum{violet!60}{-1.04+0.00i}                       & {\ccellnum{blue!40}{-1.34-1.24i}}                       & {\ccellnum{white}{1.36+0.00i}} \\
\hline
{\ccellnum{violet!20}{0.67-0.65i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.07+0.37i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.87+0.03i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.71+0.21i}} & {\ccellnum{violet!40}{0.67-0.65i}} \\
{\ccellnum{blue!60}{1.62+0.00i}}   & \textcolor{gray!50}{\ccellnum{BorderColor}{0.04+0.16i}} & \textcolor{red!50} {\ccellnum{BorderColor}{9.62+0.0i }} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.04-0.16i}} & {\ccellnum{blue!60}{1.62+0.00i}} \\
{\ccellnum{violet!40}{0.67+0.65i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.71-0.21i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.87-0.03i}} & \textcolor{gray!50}{\ccellnum{BorderColor}{0.07-0.37i}} & {\ccellnum{violet!20}{0.67+0.65i}} \\
\hline
{\ccellnum{white}{1.36+0.00i}}     & {\ccellnum{blue!40}{-1.34+1.24i}}                       & \ccellnum{violet!60}{-1.04+0.00i}                       & {\ccellnum{blue!20}{-1.34-1.24i}}                       & {\ccellnum{red!40}{1.36+0.00i}} \\
\end{tabular}
}
\caption{Left: The spectrum $\mathcal{F}(\mvec{k})$ of an even-sized ($N = 4$) and real-valued function $f(\mvec{x})$.
The zero frequency is at the center, written in red. The first row as well as the first column to the
left each contain a colour-coded complex conjugate pair. At first glance, the relation 
$\mathcal{F}(-\mvec{k})=\mathcal{F}(\mvec{k})^*$ does not seem to hold for these two pairs.
Right: The spectrum repeats itself in both directions, such as for all elements of the spectrum
there is a pair which satisfies $\mathcal{F}(-\mvec{k})=\mathcal{F}(\mvec{k})^*$.}
\label{tab:spectrum_k_minusk_border}
\end{table}
%
%https://www.cv.nrao.edu/course/astr534/FourierTransforms.html
%https://ccrma.stanford.edu/~jos/mdft/Even_Odd_Functions.html
%https://ccrma.stanford.edu/~jos/mdft/mdft.html
%https://web.eecs.umich.edu/~fessler/course/451/l/pdf/c5.pdf
The Fourier Transform of real-valued input is~\emph{hermitian} - the real part of the resulting spectrum
is an~\emph{even} function and the imaginary part is~\emph{odd}. A function $f(n)$ is said to be even if
$f(-n) = f(n)$. On the other hand, a function $f(n)$ is said to be odd if $f(-n) = -f(n)$,
with $f(0) = 0$. Let $\mathcal{F}(k)$ be the Fourier Transform of a real-valued function $f(n)$, then
the following is true:
\begin{equation}
\label{eq:dft_real_complex_conjugate}
 \mathcal{F}(-k) = \mathcal{F}(k)^*
\end{equation}
where $*$ denotes the complex conjugate operator. The relation is similar to a centrosymmetric one,
$\mathcal{F}(-k) = \mathcal{F}(k)$, with $\mathcal{F}(0)$ as a fixpoint at the center. The only
difference is the complex conjugation. Fourier Transform implementations may take advantage of
Equation~\ref{eq:dft_real_complex_conjugate} to be able to provide optimised transform functionality 
for real-valued data. For example, for a forward Fourier Transform of real-valued data it is
necessary to compute only half of the spectrum, since the other half is implicitely given as the
complex conjugate of the first half. Likewise, for the inverse Fourier Transform only half of the
spectrum is necessary, the other half is implicitely given. Such optimised transforms provide
gain in performance memory-wise, the spectrum's size is halved, as well as computation-wise, only
half the data is actually processed.\\


Surface elevation $\eta$ is a real-valued function, therefore we assume $h_0$ must be hermitian,
too. We may write
\begin{equation}
\label{eq:h0_k_complex_conjugate}
 h_0(\mvec{-k},t) = h_0(\mvec{k},t)^*
\end{equation}
where finding $h_0(\mvec{k},t)$ for its counterpart $h_0(-\mvec{k},t)$ has proven to be non-trivial
for even-sized spectra.
Let the discretised wavevector domain be zero centered and of even size in both dimensions,
then there is one row and one column of the spectrum which lacks
matching complex conjugate elements inside said domain, see the example spectrum in Table~\ref{tab:spectrum_k_minusk}.
Again, it is the periodic nature of the spectrum that gives us the solution. If we replicate
the spectrum in both directions, we obtain an additional row and an additional column which
allows us to find matching pairs for all elements of the spectrum, see Table~\ref{tab:spectrum_k_minusk_border}.\\


The spectrum $h_0(\mvec{k},t)$ as we generate it with Equation~\ref{eq:dft_h0_k_t} is~\emph{not}
hermitian, mainly because of two reasons. First, the wave energy spectrum $\Theta(\mvec{k})$ would need
to be an even function, which is only the case if the directional spread employed by
the wave energy spectrum is centrosymmetric. Only two of the directional spreading functions
presented in this work are centrosymmetric, the Unified spectrum's and the Phillips spectrum's.
Second, each element of $h_0(\mvec{k})$ is generated in combination with a pair of random numbers,
which makes it close to impossible to end up with matching pairs $h_0(-\mvec{k})=h_0(\mvec{k})^*$.
As we would like to profit from the performance gains an optimised inverse Fourier Transform
for real-valued functions offers, we are in need of a hermitian spectrum. We may rewrite
Equation~\ref{eq:dft_h0_k_t} as follows:
%
\begin{equation}
\label{eq:dft_h0_k_t_hermitian}
 h_0(\mvec{k}, t) =
 \frac{1}{2} h_0(\mvec{k})\mathrm{e}^{-\mathrm{i}\omega(\mvec{k})t}
 + \frac{1}{2} h_0(\mvec{-k})^*\mathrm{e}^{\mathrm{i}\omega(\mvec{k})t}
\end{equation}
%
which gives us a hermitian spectrum, independent both of the generated random numbers and 
whether the wave energy spectrum is an even function or not.\\


Note that surface elevation $\eta$ as computed by Equation~\ref{eq:surface_elevation_h0_k_t}
gives the same results for both variants of the spectrum, the default one given by
Equation~\ref{eq:dft_h0_k_t} as well as the hermitian given by Equation~\ref{eq:dft_h0_k_t_hermitian}.
The actual difference is that the former demands a standard inverse Fourier Transform with
a complete complex-valued source spectrum and a complex-valued result the same size. The real part
of the result represents the surface elevation, the imaginary part is to be discarded.
The latter on the other hand allows for two different kinds of optimisation. We did discuss
the first kind of optimisation already, a inverse Fourier Transform for real-valued
functions which needs less memory and less time for the computation itself. The second kind
of optimisation allows us to combine two inverse Fourier Transforms into one. Let $a(\mvec{k})$
and $b(\mvec{k})$ be hermitian spectra with the same wavevector domain $\mvec{k}$. Let $c(\mvec{x})$
and $d(\mvec{x})$ be the corresponding real-valued functions of $a(\mvec{k})$ and $b(\mvec{k})$,
then we may write:
\begin{align}
\label{eq:idft_combined}
 e(\mvec{x}) &= \mathrm{IFT}(a(\mvec{k})+\mathrm{i}b(\mvec{k})) \\
 c(\mvec{x}) &= \Re(e(\mvec{x})) \\
 d(\mvec{x}) &= \Im(e(\mvec{x})) 
\end{align}
where $\mathrm{IFT}$ is shorthand for the standard inverse Fourier Transform. In short, we combine
two complex-valued hermitian spectra to obtain two real-valued results with just one transformation.
We will make heavy use of this kind of optimisation later on.\\

\subsubsection{Complex conjugate indices}

Let us view the hermitian spectrum $h_0$ as a two dimensional array with size $N \times N$.
Each element of $h_0$ is identified by a pair of indices $(i,j)$, with $0\leq i,j <N$. Then, for
an element at index $(i,j)$, we may compute the index $(m,n)$ of the corresponding complex
conjugate element as follows:
\begin{align}
m &= (N - i)\bmod N & n &= (N - j)\bmod N
\end{align}
We may rewrite Equation~\ref{eq:h0_k_complex_conjugate} in terms of indices:
\begin{equation}
 h_0(i,j) = h_0(m,n)^*
\end{equation}

\subsubsection{Derivatives}
At this point we are able to compute surface elevation by application of the
inverse Discrete Fourier Transform on a spectrum we generate. For lighting
purposes we also need to find the surface's slope vectors to be able to compute
the surface's normal vectors. The most simple way to compute the slope is
through finite differences in the spatial domain of the surface. Such an
approach is efficient memory- and computation-wise, but may lack quality,
because it can be a poor approximation to the slope of waves with small
wavelengths. We are able to obtain more precise slope vectors by employing
\emph{spectral differentation}. Spectral differentiation allows us to find
the derivatives of a function via the Fourier Transform.\\


First we will look at the more simple, one-dimensional case of spectral
differentation. We reduce the spatial domain as well as the wavevector domain
from beforehand to one dimension. Let $N$ be the resolution of the spatial
and wavenumber domains, and $L$ the size of the spatial domain. Moreover, let
$\alpha \in \mathbb{N}$ with $\ceil{-\frac{N}{2}} \leq \alpha < \floor{\frac{N}{2}}$,
let the spatial domain be $x \in \alpha \frac{L}{N}$, and let the wavenumber
domain be $k \in \alpha \frac{2\pi}{L}$. Let $g(k)$ be the Discrete Fourier
Transform of $f(x)$, then we may write the inverse Discrete Fourier Transform
as follows:
\begin{equation}
 f(x) = \sum_{k}g(k)~\mathrm{e}^{\mathrm{i}kx}
\end{equation}
Note, that we omit the scaling factors involved in the standard Fourier Transform
because in the context of this work they are not needed. If we follow the
lead of the continuous Fourier Transform, then we may compute the $n$th
derivative of $f(x)$ as follows:
\begin{equation}
  \dod[n]{f(x)}{x} = \sum_{k}(\mathrm{i}k)^n~g(k)~\mathrm{e}^{\mathrm{i}kx}
\end{equation}
Due to aliasing issues the above is not correct for odd $n$ in combination
with even $N$. For example, if $f(x)$ is a real function, then $g(k)$ is hermitian.
But $\mathrm{i}k~g(k)$ is~\emph{not} hermitian for even $N$, therefore the first
order derivative of $f(x)$ would end up a complex function instead of a real one.
To get correct results for all $n$ and $N$, we rewrite the above equation as follows:
\begin{align}
\label{eq:dft_derivative}
  \dod[n]{f(x)}{x} &= \sum_{k}d(k, n)~g(k)~\mathrm{e}^{\mathrm{i}kx} \\
\label{eq:dft_derivative_correction}
  d(k, n) &= \begin{cases}
                   0 &\text{if $n$ odd, $N$ even, and $\abs{k} 
= \frac{N}{2}\frac{2\pi}{L}$,} \\
                   (\mathrm{i}k)^n &\text{else.}
                   \end{cases}
\end{align}
%
\begin{figure}
 \centering
 \subtop[$\eta(\mvec{x},t)$]
 {
 \label{sfig:derivative_heights}
 \includegraphics[scale=0.34]{figures/u_30_500km_heights.png}
 }
 \hfill
 \subtop[$\dpd{\eta(\mvec{x},t)}{x}$]
 {
 \label{sfig:derivative_x}
 \includegraphics[scale=0.34]{figures/u_30_500km_gradient_x.png}
 }
 \hfill
 \subtop[$\dpd{\eta(\mvec{x},t)}{y}$]
 {
 \label{sfig:derivative_z}
 \includegraphics[scale=0.34]{figures/u_30_500km_gradient_z.png}
 }
\caption{\subcaptionref{sfig:derivative_heights} An example
surface wave height realization, displayed in greyscale (Unified spectrum, 
$U_{10}=30m\cdot s^{-1}$, $F=500km$). \subcaptionref{sfig:derivative_x} The 
X-component of the slope vector.\subcaptionref{sfig:derivative_z} The 
Y-component of the slope vector.
}
\label{fig:derivatives}
\end{figure}
%
Now we may go back to the two dimensional case, with our original two dimensional
domains $\mvec{x}$ and $\mvec{k}$. The resolution of said domains is $N \times N$,
the size of the spatial domain is $L \times L$. Let $g(\mvec{k})$ be the Discrete
Fourier Transform of $f(\mvec{x})$, then we may write the inverse Discrete Fourier
Transform in two dimensions as follows:
\begin{equation}
 f(\mvec{x}) = \sum_{\mvec{k}}g(\mvec{k})~\mathrm{e}^{\mathrm{i}\transpose{\mvec{k}}\mvec{x}}
\end{equation}
Based on Equation~\ref{eq:dft_derivative}, and by reusing Equation~\ref{eq:dft_derivative_correction}
because $N$ and $L$ are equal for both dimensions, we find the derivatives of $f(\mvec{x})$:
\begin{equation}
\label{eq:dft_derivates_2d}
 \dmd{f(\mvec{x})}{n+m}{x}{n}{y}{m} = \sum_{\mvec{k}}d(k_{x}, n)d(k_{y}, m)~g(\mvec{k})~\mathrm{e}^{\mathrm{i}\transpose{\mvec{k}}\mvec{x}}
\end{equation}
where $k_x$ and $k_y$ denote the X- and Y-component of wave vector $\mvec{k}$ 
respectively. As we need to find the surface slope vector, we need to compute 
the surface elevation's first order partial derivatives. Given surface 
elevation $\eta(\mvec{x},t)$, we obtain the two dimensional surface slope 
vector $\mvec{s}$ as follows:
\begin{equation}
\label{eq:dft_slope_2d}
 \mvec{s}(\mvec{x},t) = \left[\dpd{\eta(\mvec{x},t)}{x}, \dpd{\eta(\mvec{x},t)}{y}\right]
\end{equation}
We leave it as an exercise for the reader to substitute the terms $\eta(\mvec{x},t)$
and $h_0(\mvec{k},t)$ into Equation~\ref{eq:dft_derivates_2d} to be able to
compute the surface slope vector as given in Equation~\ref{eq:dft_slope_2d}.
Figure~\ref{fig:derivatives} depicts an example instance of surface 
elevation $\eta$ as well as its associated slopes in greyscale. Brighter 
means larger values, darker means lower values. One may notice that 
Figure~\ref{sfig:derivative_heights}, without prior knowledge, is not 
recognizable as a wave heightfield. The wave heightfield's gradients in
Figure~\ref{sfig:derivative_x} and \subcaptionref{sfig:derivative_z}, on the 
other hand, are more easily identified as water waves by the human eye.\\

The two spectra which constitute the surface slope vector in the wavevector domain
are hermitian. Therefore we are able to apply the optimisation from
Equation~\ref{eq:idft_combined} which allows us to combine both spectra into one,
obtaining both components of the surface slope vector with just one inverse Fourier transform.
%
\subsubsection{Normals}
%
In this work we employ a right-handed Carthesian coordinate system where the positive
Y-axis points up. The two dimensional surface slope vector $\mvec{s}$ lies in the
coordinate system's XZ-plane. Based on the surface slope vector we may find the unit
length surface normal vector $\mvec{n}$ as follows:
\begin{equation}
 \mvec{n} = \frac{(-s_x, 1, -s_y)}{\norm{(-s_x, 1, -s_y)}}
\end{equation}
where $s_x$ and $s_y$ denote the X- and Y-component of slope vector $\mvec{s}$ 
respectively.
%
\subsubsection{Displacements}
\label{sec:displacements}
%
\begin{figure}
 \centering
 \subtop[$\eta(\mvec{x},t)$]
 {
 \label{sfig:displacement_heights}
 \includegraphics[scale=0.34]{figures/u_30_500km_heights.png}
 }
 \hfill
 \subtop[$D_x(\mvec{x},t)$]
 {
 \label{sfig:displacement_x}
 \includegraphics[scale=0.34]{figures/u_30_500km_displacement_x.png}
 }
 \hfill
 \subtop[$D_y(\mvec{x},t)$]
 {
 \label{sfig:displacement_z}
 \includegraphics[scale=0.34]{figures/u_30_500km_displacement_z.png}
 }
\caption{\subcaptionref{sfig:displacement_heights}The heightfield from 
Figure~\ref{sfig:derivative_heights}.\subcaptionref{sfig:displacement_x} The 
X-component of the displacement vector.\subcaptionref{sfig:displacement_z} The 
Y-component of the displacement vector.}
\label{fig:displacements}
\end{figure}
%
The waves generated with the methods presented up to now tend to have rounded peaks and throughs,
which is typical for fair weather conditions. But we also would like to be able to synthesize waves
matching poor weather conditions, such as strong winds or even storms. During such weather, ocean waves
are sharply peaked at their tops and flattened at the bottoms. Tessendorf\cite{course:simulatingocean}
describes a Fourier Transform based method to produce such choppy waves. The concept is simple: displace
the grid points of the spatial domain in the XZ-plane, with the displacement varying locally with the waves.
Note that the displacement is a two-dimensional vector, therefore we end up computing a vector field.
Similar to spectral differentiation, we compute an inverse Fourier transform of the spectrum $h_0$
modified with an additional term. We may write the displacement vector field as follows:
\begin{align}
%\label{eq:dft_displacement}
 \mvec{D}(\mvec{x},t) &= \left[D_x(\mvec{x},t), D_y(\mvec{x},t)\right]\\
 D_x(\mvec{x},t) &= \sum_{\mvec{k}}d(k_x, k)~h_0(\mvec{k},t)~\mathrm{e}^{\mathrm{i}\transpose{\mvec{k}}\mvec{x}} \\
 D_y(\mvec{x},t) &= \sum_{\mvec{k}}d(k_y, k)~h_0(\mvec{k},t)~\mathrm{e}^{\mathrm{i}\transpose{\mvec{k}}\mvec{x}} \\
%\label{eq:dft_displacement_correction}
 d(l, k) &= \begin{cases}
             0 &\text{if $N$ even, and $k = 0$ or $\abs{l} = 
\frac{N}{2}\frac{2\pi}{L}$,} \\
             -\mathrm{i}\frac{l}{k} &\text{else.}
            \end{cases}
\end{align}
where the term $d(l, k)$ in addition to make sure the resulting spectrum is 
hermitian also avoids a division by zero at $k = 0$. 
Figure~\ref{fig:displacements} shows an example instance of surface elevation 
$\eta$ as well as its associated displacements in greyscale. As before, 
brighter means larger values, darker means lower values. Given the displacement 
vectors $\mvec{D}$, as well as the original grid points $\mvec{x}$, we may 
compute the displaced gridpoints $\mvec{y}$ as follows:
\begin{equation}
 \mvec{y} = \mvec{x} - \lambda \mvec{D}(\mvec{x}, t)
\end{equation}
where $\lambda$ is a user-controlled parameter to scale the importance of the
displacement vector. As one can see, it is not the wave heights that are 
altered, but instead the grid points on the XZ-plane are transformed based on 
the spatial structure of the height field. This particular transformation
accomplishes the effects we sought, the waves' peaks are sharpened and the 
waves' valleys are broadened, see Figure~\ref{fig:grid_displaced}.
%
\begin{figure}
\centering
\begin{tikzpicture}
\begin{axis}[
	width=\textwidth,
	height=4cm,
    legend style={draw=none},
    %legend/.append style={nodes={right}},
	legend pos= south west,
	legend cell align=left,
	xtick = {-50, -40, -30, -20, -10, 0, 10, 20, 30, 40, 50},
	ytick = {-0.5, 0, 0.5},
    xlabel={Spatial domain coordinate~$x$~($\text{m}$)},
    ylabel={Surface height~$\eta$~($\text{m}$)},
%	enlarge x limits = auto,
]
\addplot[
    color=red,
    solid,
	]
    table [
		col sep=comma, 
		x expr=\thisrowno{0},
		y expr=\thisrowno{2},
	]
	{figures/u_30_500km_x_dx_h.dat};
\addlegendentry{$x$}
\addplot[
    color=blue,
    solid,
	]
    table [
		col sep=comma, 
		x expr=\thisrowno{0} - 5*\thisrowno{1},
		y expr=\thisrowno{2},
	]
	{figures/u_30_500km_x_dx_h.dat};
\addlegendentry{$x - \lambda D_x$}
\end{axis}
\end{tikzpicture}
\caption{Red: the original grid points. Blue: the displaced grid points, note 
the steep tops and the flattened valleys.}
\label{fig:grid_displaced}
\end{figure}

\subsubsection{Whitecaps}
%
\cite{course:simulatingocean}
\cite{article:whitecaps}

% \begin{tabular}{lS[table-format = 3]S[table-format = 3.2]}
% \toprule
%   \textbf{Bus} & \multicolumn{2}{c}{\textbf{Bus Load (MVA)}} \\
%                & {Real} & {Complex} \\
%   \midrule
%   b1 &  50 &  30.99 \\
%   b2 & 170 & 105.35 \\
%   b3 & 200 & 123.94 \\
%   b4 & 150 &  49.58 \\
%   \bottomrule
% \end{tabular}


