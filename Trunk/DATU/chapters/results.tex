\chapter{Results}
\label{ch:results}
%
% The scope of this thesis includes the generation, animation and rendering of the
% surface of an open ocean in real-time. We focus our interest on the synthesis of
% animated ocean surface geometry, for which we will adopt a set of models from
% oceanographic research.

The previous chapter discussed in detail the approach we took to synthesize
the animated ocean surface, including, one, a number of optimizations to reduce
the computational workload, and, two, a level of detail mechanism which does
not only give us fine-grained control over model detail, but also allows us to
reduce potential tiling artifacts. Additionally, we gave an overview of our demo
application, which integrates our approach to ocean surface synthesis
with real-time rendering algorithms which have been developed specifically for
the display of the open ocean.
Thus, with our demo application at hand, we may move on to discuss the
actual results we were able to achieve.

The remainder of this chapter is organized as follows:
Section \ref{sec:results:performance} gives a compact overview of the performance
improvements which we were able to attain for the computation of the sum
of waves via the \InvFourierTransform.
Section \ref{sec:results:synthesis} delineates the pitfalls we encountered
in the context of ocean surface synthesis with wave spectra, and what measures
we took to either overcome or sidestep them.
Last, Section \ref{sec:results:fidelity} discusses the level of visual fidelity
we were able to obtain, with focus on the different wave spectra, as well as
our level of detail approach.

% Before we delve into details, one may look at Figure~\ref{fig:results} which
% depicts all componenents which are part of our ocean lighting implementation.
% compare lighting of all spectrum types (same parameters)

\section{Performance}
\label{sec:results:performance}
%
\begin{figure}
\centering
%\tikzset{external/force remake}
\pgfplotstableread[col sep = comma]{figures/benchmark_H0_i5_5300u.dat}\mydata
\begin{tikzpicture}[trim axis left]
  \begin{axis}[
    legend pos = north west,
    xticklabels from table={\mydata}{Resolution},
    xtick=data,
    xlabel={Resolution [\si{\pixel}]},
    ylabel={Time [\si{\ms}]},
    legend style={draw=none},
    every axis legend/.append style={nodes={right}},
    ]
    \addplot [color=blue] table[x expr=\coordindex, y index = {1}]{\mydata};
    \addplot [color=green] table[x expr=\coordindex, y index = {2}]{\mydata};
    \addplot [color=black] table[x expr=\coordindex, y index = {3}]{\mydata};
    \addplot [color=red] table[x expr=\coordindex, y index = {4}]{\mydata};

    \addplot[color=black,dashed] coordinates {
    (0,200)
    (5,200)
    }
    node[below,pos=0.5] {5 fps};
    \addplot[color=black,dotted] coordinates {
    (0,400)
    (5,400)
    }
    node[below,pos=0.5] {2.5 fps};

    % assemble legend
    \pgfplotstablegetcolsof{\mydata}
    \pgfmathparse{\pgfplotsretval-1}
    \foreach \n in {1,...,\pgfmathresult} {
      \pgfplotstablegetcolumnnamebyindex{\n}\of{\mydata}\to{\colname}
      \addlegendentryexpanded{\colname}
    }
  \end{axis}
\end{tikzpicture}
\caption{Computation times for the static part of the spectrum at various
resolutions with different underlying wave energy spectra.
One can see that at higher resolutions we would be unable to synthesize the
static part of the spectrum more than a few times a second, much less so if
we would employ more than one level of detail.}
\label{fig:results:h0}
\end{figure}


%
%
% \begin{table}
% \centering
% \begin{tabular}{@{}l*2{S[table-format=1.2]}*2{S[table-format=2.2]}*2{S[table-format=3.2]}@{}}
% \toprule
% Spectrum & \multicolumn{6}{c}{Time [\si{\ms}]}       \\ \midrule
%          & \multicolumn{6}{c}{Resolution} \\ \cmidrule(l){2-7} 
%          & {$32\times32$} & {$64\times64$}  & {$128\times128$}  & {$256\times256$}  & {$512\times512$} & {$1024\times1024$} \\
% \midrule
% \csvreader[late after line=\\,late after last line=\\\bottomrule]{figures/benchmark_H0_i5_5300u.csv}{}{\csvcoli & \csvcoliv & \csvcolv & \csvcolvi & \csvcolvii & \csvcolviii & \csvcolix}
% \end{tabular}
% \caption{Computation times for the static part of the spectrum at various resolutions
% with different underlying wave energy spectra. One can see that at larger resolutions
% we would be unable to synthesize the static part of the spectrum more than a few times
% a second, much less so in case of more than one level of detail.}
% \label{tab:results:h0}
% \end{table}
%
% \begin{table}
% \centering
% \begin{tabular}{@{}l*2{S[table-format=1.2]}*2{S[table-format=2.2]}*2{S[table-format=3.2]}@{}}
% \toprule
% Spectrum & \multicolumn{6}{c}{Time [\si{\ms}]}       \\ \midrule
%          & \multicolumn{6}{c}{Resolution} \\ \cmidrule(l){2-7} 
%          & {$32\times32$} & {$64\times64$}  & {$128\times128$}  & {$256\times256$}  & {$512\times512$} & {$1024\times1024$} \\
% \midrule
% Heights         & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
% + Displacements & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
% + Gradients     & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
% + Displ Deriv   & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
% \bottomrule
% \end{tabular}
% \caption{Computation times for a single pattern at various resolutions, where
% each row adds the spectra of the respective dataset to the pattern. Thus, at
% first we have one pattern with only the height spectrum, and in the final row
% we have one pattern with all nine spectra: one for height, two for displacements,
% two for gradients, and four for displacement derivatives.
% As all datasets share most of the arithmetic, it is the extra stores to memory
% that require the bulk of the additional CPU time.}
% \label{tab:results:all}
% \end{table}
%
We have seen in Section~\ref{sec:spectrum_synthesis} that the underlying
spectrum of the animated ocean surface consists of two parts, a static part
and a time-dependent part.
As long as the \wavevector domain and the wave energy spectrum parameters do
not change, the static part of the spectrum has to be computed only once for
the entire lifetime of the animated ocean surface.
Moreover, as it is the static part of the spectrum that incorporates the wave
energy spectrum, we are relieved of a significant computational burden.
That is because evaluating the wave energy spectrum for a large set of
\wavevectors has proven to be extensive in terms of computational complexity.
See Figure~\ref{fig:results:h0}, which gives an overview of measurements we
have taken for the computation time of the static part of the spectrum for a
single ocean surface tile.
%
\begin{figure}
\centering
%\tikzset{external/force remake}
\pgfplotstableread[col sep = comma]{figures/benchmark_H_i5_5300u.dat}\mydata
\begin{tikzpicture}[trim axis left]
  \begin{axis}[
    legend pos = north west,
    stack plots = y,
    area style,
    xticklabels from table={\mydata}{Resolution},
    xtick=data,
    xlabel={Resolution [\si{\pixel}]},
    ylabel={Time [\si{\ms}]},
    legend style={draw=none},
    every axis legend/.append style={nodes={right}},
    ]
    \addplot [color=black,fill=black,fill opacity=0.25] table [x expr=\coordindex,y=Heights] from \mydata \closedcycle; 
    \addplot [color=red,fill=red,fill opacity=0.25] table [x expr=\coordindex,y=Slopes] from \mydata \closedcycle;
    \addplot [color=green,fill=green,fill opacity=0.25] table [x expr=\coordindex,y=Displacements] from \mydata \closedcycle;
    \addplot [color=blue,fill=blue,fill opacity=0.25] table [x expr=\coordindex,y=Displacement Derivatives] from \mydata \closedcycle;
    
    \addplot[color=black,dashed] coordinates {
      (0,20)
      (5,20)
      }
      node[below,pos=0.5] {50 fps};
    \addplot[color=black,dotted] coordinates {
      (0,20)
      (5,20)
      }
    node[below,pos=0.5] {25 fps};
%     assemble legend
    \pgfplotstablegetcolsof{\mydata}
    \pgfmathparse{\pgfplotsretval-1}
    \foreach \n in {1,...,\pgfmathresult} {
      \pgfplotstablegetcolumnnamebyindex{\n}\of{\mydata}\to{\colname}
      \addlegendentryexpanded{\colname}
    }
  \end{axis}
\end{tikzpicture}
\caption{Accumulated computation times for the generation of spectra at various
resolutions for a single ocean surface pattern. We start at the bottom with
the computation times we measured for the height spectrum, and step by step add
the timings of the remaining datasets.
One can see that the generation of the height spectrum alone takes the better
part of the entire computation time.
That is because all datasets share most of the arithmetic operations.
The bulk of the CPU time spent on the supplemental datasets is caused by the
additional stores to memory.
Moreover, one can see that for all resolutions in question, except the highest
one, we are able to generate all spectra of the ocean surface pattern in
real-time.
}
\label{fig:results:h}
\end{figure}
%

With the static part of the spectrum on hand in a precomputed form, we are able
to compute the spectra of all datasets within a fraction of time so short that
we may synthesize the animated ocean surface tile in real-time on the CPU.
Figure~\ref{fig:results:h} gives an overview of measurements we have taken for
the accumulated computation time of all spectral datasets for a single ocean
surface tile.
% described in Section~\ref{sec:discrete_fourier_transform}\ref{sec:slopes_and_displacements}
%

\begin{figure}
\centering
\tikzset{external/force remake}
\pgfplotstableread[col sep = comma]{figures/benchmark_lods_h_i5_5300u.dat}\lodsh
\pgfplotstableread[col sep = comma]{figures/benchmark_lods_h_g_i5_5300u.dat}\lodshg
\pgfplotstableread[col sep = comma]{figures/benchmark_lods_h_g_d_i5_5300u.dat}\lodshgd
\pgfplotstableread[col sep = comma]{figures/benchmark_lods_h_g_d_dd_i5_5300u.dat}\lodshgddd

\begin{tikzpicture}
\begin{groupplot}[
	group style={
	  columns=2,
	},
% 	xlabel={\Wavenumber~$k$~(\si{\radian\per\meter})},
	width=0.5\textwidth,
	%scaled ticks=false,
	legend columns=-1,
	legend style={/tikz/every even column/.append style={column sep=0.5cm}},
	]
\nextgroupplot[
%     legend pos = north west,
    legend to name=grouplegend,
    stack plots = y,
    area style,
    xticklabels from table={\lodsh}{Resolution},
    xtick=data,
    xlabel={Resolution [\si{\pixel}]},
    ylabel={Time [\si{\ms}]},
    ymax = 295,
    title = {Heights},
%     y post scale = 1.5,
%     legend style={draw=none},
%     every axis legend/.append style={nodes={right}},
    ]
    \addplot [color=black,fill=black,fill opacity=0.25] table [x expr=\coordindex,y=1] from \lodsh \closedcycle; 
    \addplot [color=red,fill=red,fill opacity=0.25] table [x expr=\coordindex,y=2] from \lodsh \closedcycle;
    \addplot [color=green,fill=green,fill opacity=0.25] table [x expr=\coordindex,y=3] from \lodsh \closedcycle;
    \addplot [color=blue,fill=blue,fill opacity=0.25] table [x expr=\coordindex,y=4] from \lodsh \closedcycle;
    
    %     assemble legend
    \pgfplotstablegetcolsof{\lodsh}
    \pgfmathparse{\pgfplotsretval-1}
    \foreach \n in {1,...,\pgfmathresult} {
      \pgfplotstablegetcolumnnamebyindex{\n}\of{\lodsh}\to{\colname}
      \addlegendentryexpanded{LOD~\colname}
    }
\nextgroupplot[
%     legend pos = north west,
    stack plots = y,
    area style,
    xticklabels from table={\lodshgddd}{Resolution},
    xtick=data,
    xlabel={Resolution [\si{\pixel}]},
    ymax = 295,
    title = {All Datasets},
%     y post scale = 1.5,
%     ylabel={Time [\si{\ms}]},
%     legend style={draw=none},
%     every axis legend/.append style={nodes={right}},
    ]
    \addplot [color=black,fill=black,fill opacity=0.25] table [x expr=\coordindex,y=1] from \lodshgddd \closedcycle; 
    \addplot [color=red,fill=red,fill opacity=0.25] table [x expr=\coordindex,y=2] from \lodshgddd \closedcycle;
    \addplot [color=green,fill=green,fill opacity=0.25] table [x expr=\coordindex,y=3] from \lodshgddd \closedcycle;
    \addplot [color=blue,fill=blue,fill opacity=0.25] table [x expr=\coordindex,y=4] from \lodshgddd \closedcycle;
\end{groupplot}
\node at ($(group c1r1.south)!0.5!(group c2r1.south)$)
[below,
yshift=-3\pgfkeysvalueof{/pgfplots/every axis title shift}
] 
{\pgfplotslegendfromname{grouplegend}};
\end{tikzpicture}
\caption{KABUMM.}
\end{figure}


% \begin{figure}
% \centering
% % \tikzset{external/force remake}
% \pgfplotstableread[col sep = comma]{figures/benchmark_lods_h_g_d_dd_i5_5300u.dat}\mydata
% \begin{tikzpicture}
%   \begin{axis}[
%     legend pos = north west,
%     stack plots = y,
%     area style,
%     xticklabels from table={\mydata}{Resolution},
%     xtick=data,
%     xlabel={Resolution [\si{\pixel}]},
%     ylabel={Time [\si{\ms}]},
%     legend style={draw=none},
%     every axis legend/.append style={nodes={right}},
%     ]
%     \addplot [color=black,fill=black,fill opacity=0.25] table [x expr=\coordindex,y=1] from \mydata \closedcycle; 
%     \addplot [color=red,fill=red,fill opacity=0.25] table [x expr=\coordindex,y=2] from \mydata \closedcycle;
%     \addplot [color=green,fill=green,fill opacity=0.25] table [x expr=\coordindex,y=3] from \mydata \closedcycle;
%     \addplot [color=blue,fill=blue,fill opacity=0.25] table [x expr=\coordindex,y=4] from \mydata \closedcycle;
% %     assemble legend
%     \pgfplotstablegetcolsof{\mydata}
%     \pgfmathparse{\pgfplotsretval-1}
%     \foreach \n in {1,...,\pgfmathresult} {
%       \pgfplotstablegetcolumnnamebyindex{\n}\of{\mydata}\to{\colname}
%       \addlegendentryexpanded{LOD~\colname}
%     }
%   \end{axis}
% \end{tikzpicture}
% \caption{Accumulated computation times for the generation of up to four
% ocean surface patterns at various resolutions.}
% \end{figure}

\begin{figure}
\centering
% \tikzset{external/force remake}
\pgfplotstableread[col sep = comma]{figures/benchmark_fftwf_i5_5300u.dat}\fftwf
\pgfplotstableread[col sep = comma]{figures/benchmark_fftw_i5_5300u.dat}\fftw
\begin{tikzpicture}[trim axis left]
  \begin{axis}[
    legend pos = north west,
    xticklabels from table={\fftw}{Resolution},
    xtick=data,
    xlabel={Resolution [\si{\pixel}]},
    ylabel={Time [\si{\ms}]},
    legend style={draw=none},
    every axis legend/.append style={nodes={right}},
    ]
    \addplot [color=blue] table[x expr=\coordindex, y index = {1}]{\fftwf};
    \addlegendentry{Single Precision}
    \addplot [color=red] table[x expr=\coordindex, y index = {1}]{\fftw};
    \addlegendentry{Double Precision}
    \addplot [color=black,loosely dashed] table[x expr=\coordindex, y expr = \thisrowno{1}*2]{\fftwf};
    % assemble legend
%     \pgfplotstablegetcolsof{\fftw}
%     \pgfmathparse{\pgfplotsretval-1}
%     \foreach \n in {1,...,\pgfmathresult} {
%       \pgfplotstablegetcolumnnamebyindex{\n}\of{\fftw}\to{\colname}
%       \addlegendentryexpanded{\colname}
%     }
  \end{axis}
\end{tikzpicture}
\caption{}
\end{figure}
%
% \begin{table}[]
% \centering
% % H generation with quadrant swapping
% % #Lods   8     16    32    64   128   256    512    1024 
% %     1 0.006 0.024 0.080 0.280 1.124  4.511 18.301  75.322 
% %     2 0.009 0.036 0.141 0.581 2.336  9.274 38.325 153.983 
% %     3 0.014 0.054 0.216 0.879 3.523 14.222 58.711 234.903 
% %     4 0.018 0.073 0.294 1.207 4.798 19.733 80.774 319.490
% \begin{tabular}{@{}c*2{S[table-format=1.2]}*2{S[table-format=2.2]}*2{S[table-format=3.2]}@{}}
% \toprule
% \#Lods & \multicolumn{6}{c}{Time [\si{\ms}]}       \\ \midrule
%          & \multicolumn{6}{c}{Resolution} \\ \cmidrule(l){2-7} 
%          & {$32\times32$} & {$64\times64$}  & {$128\times128$}  & {$256\times256$}  & {$512\times512$} & {$1024\times1024$} \\
% \midrule
% 1 & 0.080  & 0.280   & 1.124    &  4.511    & 18.301   &  75.322    \\
% 2 & 0.141  & 0.581   & 2.336    &  9.274    & 38.325   & 153.983    \\
% 3 & 0.216  & 0.879   & 3.523    & 14.222    & 58.711   & 234.903    \\
% 4 & 0.294  & 1.207   & 4.798    & 19.733    & 80.774   & 319.490    \\
% \bottomrule
% \end{tabular}
% \caption{}
% \label{tab:results:h:equal:resolution}
% \end{table}
%
%
Table~\ref{tab:results:h:equal:resolution} timings for spectrum synthesis
(geometry, displacements, gradients, displacement derivatives) with
different number of level of detail. Then a table with FFTW timings.
Then a H generation table where geometry resolution lower than gradient resolution.
% The static part has to be recomputed only in
% case the \wavevector domain or parameters for the wave energy spectrum change.
% 
% as long parameters do
% not change, the spectrum is static, except for the animation term. Thus, we are
% able to lighten the computational load significantly, because evaluating the
% wave energy at a large number of \wavenumbers is expensive.
% \ref{eq:dft_h0_k}
% \ref{eq:dft_h_k_t_hermitian}
% \ref{sec:discrete_fourier_transform}

% H generation
% #Lods 8 16 32 64 128 256 512 1024 
% 1 0.006 0.024 0.081 0.273 1.095 4.397 17.409 70.361 
% 2 0.008 0.034 0.138 0.566 2.264 9.005 36.332 142.816 
% 3 0.013 0.052 0.213 0.867 3.449 13.660 54.651 220.256 
% 4 0.018 0.071 0.291 1.189 4.707 18.817 75.083 298.944 

% H generation with quadrant swapping
% #Lods 8 16 32 64 128 256 512 1024 
% 1 0.006 0.024 0.080 0.280 1.124 4.511 18.301 75.322 
% 2 0.009 0.036 0.141 0.581 2.336 9.274 38.325 153.983 
% 3 0.014 0.054 0.216 0.879 3.523 14.222 58.711 234.903 
% 4 0.018 0.073 0.294 1.207 4.798 19.733 80.774 319.490

% FFTW
% 8 16 32 64 128 256 512 1024 
% 0.0002 0.0008 0.0036 0.0129 0.0500 0.2640 1.2314 7.0269

We did not reproduce the current state of art with regard to the \FourierTransform,
i.e. compute the \IDFT on the GPU (GPGPU, CUDA, clfft). The reasons are varying,
but the most compelling is debugging. We have found it difficult to make sure
that the spectrum is synthesized correctly, because it is essentially gaussian noise,
thus deviations caused by a faulty implementation still lead to results which hold
up to casual scrutiny. Thus, keeping all spectrum related computation on the
CPU side allowed us to assert corretness more easily.
As we already did a MATLAB implementation and a native one
in ObjC, an additional one would have expanded the scope of this work unreasonably.
Still, FFTW does an acceptable job performancewise. Note, that we employed the
float precision variant of FFTW, since it has proven to provide sufficient
numerical accuracy for our use case, and outperforms the double precision variant
by a factor of 1.5.

Simple \InvFourierTransform vs \InvFourierTransform of two hermitian spectra
Pattern synthesis at full resolution for all datasets
Pattern synthesis with our multi-resolution approach

\emph{Note}: All measurements of computation time have been taken on an Intel
Core i5 5300U Mobile Processor. All our benchmarking code runs single-threaded
and gives the average computation time after running the desired task for a
thousand iterations.

\section{Pattern Synthesis}
\label{sec:results:synthesis}
Although all spectrum types give convincing results geometry-wise, it is the
Preetham spectrum and the Unified spectrum that work best with the lighting
algorithm by \cite{article:oceanlighting}. Probable cause is that the JONSWAP
spectrum and the Donelan spectrum give not that good an approximation of the
ocean surface's mean square slope (\ref{app:mss}). The mean square slope is a
core component of the lighting model by \cite{article:oceanlighting}, and thus
has large influence on the result.

In the beginning we needed several fudge factors to generate acceptable results,
specifically, we were always required to add some scaling factor in the XZ plane
or in the Y direction. And the fudge factors needed to change if spectrum
parameters changed.
Only after implementing correct integral domain conversion for the different
spectra did we obtain consistent results across all spectrum models. It made all
the difference, since now we get consistent, believable as well as
comprehensible results for all spectra. No fudge factors are required anymore,
everything works out of the box.

\section{Visual Fidelity}
\label{sec:results:fidelity}
%
\begin{figure}
\centering
 \subtop[Sun Contribution]
 {
  \includegraphics[width=0.48\textwidth]{figures/31-07-2017_10-47-08_ross.png}
	\label{fig:results:ross}
 }
 \hfill
 \subtop[Sky Contribution]
 {
  \includegraphics[width=0.48\textwidth]{figures/31-07-2017_10-47-08_sky.png}
	\label{fig:results:sky}
 }
 \hfill
 \subtop[Sea Contribution]
 {
  \includegraphics[width=0.48\textwidth]{figures/31-07-2017_10-47-08_sea.png}
	\label{fig:results:sea}
 }
 \hfill
 \subtop[Whitecaps Contribution]
 {
  \includegraphics[width=0.48\textwidth]{figures/31-07-2017_10-47-08_whitecaps.png}
	\label{fig:results:whitecaps}
 }
 \hfill
 \subtop[Final Result]
 {
  \includegraphics[width=\textwidth]{figures/31-07-2017_10-47-08_complete.png}
	\label{fig:results:complete}
 }
\caption{An overview of all ocean lighting terms involved in our implementation
of \citet{article:oceanlighting,misc:oceanlightingfft} and \citet{article:whitecaps}.
\subcaptionref{fig:results:ross} Sun light reflected by the water surface.
\subcaptionref{fig:results:sky} Sky light reflected by the water surface.
\subcaptionref{fig:results:sea} Light refracted from the water body.
\subcaptionref{fig:results:whitecaps} Whitecap foam.
\subcaptionref{fig:results:complete} All previous terms combined into the final
result.
}
\label{fig:results}
\end{figure}
%
Images of all partial terms involved in ocean lighting (specular by sun,
reflection of sky, refracted light, whitecaps)

Troubles with reflection vectors below horizon
Troubles with bright patches caused by reflection
Troubles with dark patches caused by reflection
Troubles with sundisk (XYZ to sRGB)

Tiling images

Comparison full resolution patterns vs multi-resolution scheme

Maybe different tonemapping settings