float4x4 mvp : NPMODELVIEWPROJECTION;
sampler2D grassDiffuse  : NPCOLORMAP0;
sampler2D grassSpecular : NPCOLORMAP1;
sampler2D stoneDiffuse  : NPCOLORMAP2;
sampler2D stoneSpecular : NPCOLORMAP3;
sampler2D sandDiffuse   : NPCOLORMAP4;
sampler2D sandSpecular  : NPCOLORMAP5;
sampler2D sandToGrass   : NPCOLORMAP6;
sampler2D grassToStone  : NPCOLORMAP7;

float3 lightDirection;
float3 cameraPosition;
float2 texCoordTiling;
float2 heightRange;

struct INPUTDATA
{
	float4 position			: POSITION;
    float3 normal           : NORMAL;
	float2 texcoord		    : TEXCOORD0;
    float3 AO               : COLOR0;
};

struct VOUTPUTDATA
{
	float4 position			: POSITION;
	float2 texcoord			: TEXCOORD0;
    float3 normal           : TEXCOORD1;
    float3 worldPosition    : TEXCOORD2;
    float3 AO               : TEXCOORD3;
};

VOUTPUTDATA mvertexshader(INPUTDATA input)
{
	VOUTPUTDATA output;

	output.position = mul(mvp, input.position);
    output.texcoord = input.texcoord;
    output.normal   = input.normal;
    output.worldPosition = input.position.xyz;
    output.AO = input.AO;
	
	return output;
}

struct FOUTPUTDATA
{
	float4 color			: COLOR0;
};

FOUTPUTDATA mfragmentshader(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float2 texcoord = input.texcoord * texCoordTiling;

    float3 normal = normalize(input.normal);
    float3 reflectionVector = -2.0f * normal * dot(normal, -lightDirection) - lightDirection;
    float3 eyeVector = cameraPosition - input.worldPosition;

    float heightRangeLength = abs(heightRange.y - heightRange.x);
    float heightRangeScale = 1.0f / heightRangeLength;
    float normalisedHeight = input.worldPosition.y * heightRangeScale - (0.5f * heightRangeScale);

    float3 sandColor = tex2D(sandDiffuse, texcoord).rgb;
    float3 grassColor = tex2D(grassDiffuse, texcoord).rgb;
    float3 stoneColor = tex2D(stoneDiffuse, texcoord).rgb;
    float sandSpecularFactor = tex2D(sandSpecular, texcoord).x;
    float grassSpecularFactor = tex2D(grassSpecular, texcoord).x;
    float stoneSpecularFactor = tex2D(stoneSpecular, texcoord).x;

    float3 diffuseColor = float3(1.0f);
    float specularFactor = 0.0f;

    if ( normalisedHeight < 0.05f )
    {
        diffuseColor = sandColor;
        specularFactor = sandSpecularFactor;
    }
    else if ( normalisedHeight < 0.1f )
    {
        float blendingFactor = tex2D(sandToGrass, texcoord).x;
        diffuseColor = (1.0f - blendingFactor) * grassColor + blendingFactor * sandColor;
        specularFactor = (1.0f - blendingFactor) * grassSpecularFactor + blendingFactor * sandSpecularFactor;
    }
    else if ( normalisedHeight < 0.6f )
    {
        diffuseColor = grassColor;
        specularFactor = grassSpecularFactor;
    }
    else if ( normalisedHeight < 2.0f/3.0f )
    {
        float blendingFactor = tex2D(grassToStone, texcoord).x;
        diffuseColor = (1.0f - blendingFactor) * stoneColor + blendingFactor * grassColor;
        specularFactor = (1.0f - blendingFactor) * stoneSpecularFactor + blendingFactor * grassSpecularFactor;
    }
    else
    {
        diffuseColor = stoneColor;
        specularFactor = stoneSpecularFactor;
    }

    float ambient = input.AO.x;
    float diffuse = max(0.0f, dot(normal, lightDirection));
    float specular = 0.0f;

    if ( diffuse > 0.0f )
    {
        specular = max(0.0f, dot(reflectionVector, eyeVector)) * specularFactor;
    }

    output.color = float4(diffuseColor * (ambient + diffuse + specular), 1.0);

	return output;
}

FOUTPUTDATA mfragmentshader_diffuse_and_specular(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float2 texcoord = input.texcoord * texCoordTiling;

    float3 normal = normalize(input.normal);
    float3 reflectionVector = -2.0f * normal * dot(normal, -lightDirection) - lightDirection;
    float3 eyeVector = cameraPosition - input.worldPosition;

    float heightRangeLength = abs(heightRange.y - heightRange.x);
    float heightRangeScale = 1.0f / heightRangeLength;
    float normalisedHeight = input.worldPosition.y * heightRangeScale - (0.5f * heightRangeScale);

    float3 sandColor = tex2D(sandDiffuse, texcoord).rgb;
    float3 grassColor = tex2D(grassDiffuse, texcoord).rgb;
    float3 stoneColor = tex2D(stoneDiffuse, texcoord).rgb;
    float sandSpecularFactor = tex2D(sandSpecular, texcoord).x;
    float grassSpecularFactor = tex2D(grassSpecular, texcoord).x;
    float stoneSpecularFactor = tex2D(stoneSpecular, texcoord).x;

    float3 diffuseColor = float3(1.0f);
    float specularFactor = 0.0f;

    if ( normalisedHeight < 0.05f )
    {
        diffuseColor = sandColor;
        specularFactor = sandSpecularFactor;
    }
    else if ( normalisedHeight < 0.1f )
    {
        float blendingFactor = tex2D(sandToGrass, texcoord).x;
        diffuseColor = (1.0f - blendingFactor) * grassColor + blendingFactor * sandColor;
        specularFactor = (1.0f - blendingFactor) * grassSpecularFactor + blendingFactor * sandSpecularFactor;
    }
    else if ( normalisedHeight < 0.6f )
    {
        diffuseColor = grassColor;
        specularFactor = grassSpecularFactor;
    }
    else if ( normalisedHeight < 2.0f/3.0f )
    {
        float blendingFactor = tex2D(grassToStone, texcoord).x;
        diffuseColor = (1.0f - blendingFactor) * stoneColor + blendingFactor * grassColor;
        specularFactor = (1.0f - blendingFactor) * stoneSpecularFactor + blendingFactor * grassSpecularFactor;
    }
    else
    {
        diffuseColor = stoneColor;
        specularFactor = stoneSpecularFactor;
    }

    float ambient = 0.2f;
    float diffuse = max(0.0f, dot(normal, lightDirection));
    float specular = 0.0f;

    if ( diffuse > 0.0f )
    {
        specular = max(0.0f, dot(reflectionVector, eyeVector)) * specularFactor;
    }

    output.color = float4(diffuseColor * (ambient + diffuse + specular), 1.0);

	return output;
}

FOUTPUTDATA mfragmentshader_diffuse_only(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float2 texcoord = input.texcoord * texCoordTiling;

    float3 normal = normalize(input.normal);

    float heightRangeLength = abs(heightRange.y - heightRange.x);
    float heightRangeScale = 1.0f / heightRangeLength;
    float normalisedHeight = input.worldPosition.y * heightRangeScale - (0.5f * heightRangeScale);

    float3 sandColor = tex2D(sandDiffuse, texcoord).rgb;
    float3 grassColor = tex2D(grassDiffuse, texcoord).rgb;
    float3 stoneColor = tex2D(stoneDiffuse, texcoord).rgb;

    float3 diffuseColor = float3(1.0f);

    if ( normalisedHeight < 0.05f )
    {
        diffuseColor = sandColor;
    }
    else if ( normalisedHeight < 0.1f )
    {
        float blendingFactor = tex2D(sandToGrass, texcoord).x;
        diffuseColor = (1.0f - blendingFactor) * grassColor + blendingFactor * sandColor;
    }
    else if ( normalisedHeight < 0.6f )
    {
        diffuseColor = grassColor;
    }
    else if ( normalisedHeight < 2.0f/3.0f )
    {
        float blendingFactor = tex2D(grassToStone, texcoord).x;
        diffuseColor = (1.0f - blendingFactor) * stoneColor + blendingFactor * grassColor;
    }
    else
    {
        diffuseColor = stoneColor;
    }

    float ambient = 0.2f;
    float diffuse = max(0.0f, dot(normal, lightDirection));

    output.color = float4(diffuseColor * (ambient + diffuse), 1.0);

	return output;
}

technique terrain
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique terrain_diffuse_and_specular
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader_diffuse_and_specular();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique terrain_diffuse_only
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader_diffuse_only();
		VertexProgram = compile vp40 mvertexshader();
	}
}

