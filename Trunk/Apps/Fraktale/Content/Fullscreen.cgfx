float4x4 mvpmatrix   : NPMODELVIEWPROJECTION;
sampler2D colormap0  : NPCOLORMAP0;
sampler2D colormap1  : NPCOLORMAP1;
float2 rViewport     : NPRVIEWPORTSIZE;

float bloomThreshold;
float bloomIntensity;
float bloomSaturation;
float sceneIntensity;
float sceneSaturation;
float3 toneMappingParameters; // x = averageLuminance, y = referenceWhite, z = key

static const float gauss15x15[15] =
{
    0.000004964030580f,
    0.000089220150510f,
    0.001028185997527f,
    0.007597324015865f,
    0.035993977675459f,
    0.109340049783996f,
    0.212965337014902f,
    0.265961520267622f,
    0.212965337014902f,
    0.109340049783996f,
    0.035993977675459f,
    0.007597324015865f,
    0.001028185997527f,
    0.000089220150510f,
    0.000004964030580f
};

// http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html

static float3x3 RGB2XYZ = { 0.4124564f,  0.2126729f,  0.0193339f,
                            0.3575761f,  0.7151522f,  0.1191920f,
                            0.1804375f,  0.0721750f,  0.9503041f };

static float3x3 XYZ2RGB = { 3.2404542f, -0.9692660f,  0.0556434f,
                           -1.5371385f,  1.8760108f, -0.2040259f,
                           -0.4985314f,  0.0415560f,  1.0572252f };

struct INPUTDATA
{
	float4 position			: POSITION;
    float2 texcoord         : TEXCOORD0;
};

struct VOUTPUTDATA
{
	float4 position			: POSITION;
    float2 texcoord         : TEXCOORD0;
};

VOUTPUTDATA mvertexshader(INPUTDATA input)
{
	VOUTPUTDATA output;

	output.position = mul(mvpmatrix, input.position);
    output.texcoord = input.texcoord;
	
	return output;
}

struct FOUTPUTDATA
{
	float4 color			: COLOR0;
};

FOUTPUTDATA mfragmentshader(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    output.color = tex2D(colormap0, input.texcoord);

	return output;
}

FOUTPUTDATA mbloomextract(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    // Look up the original image color.
    float4 color = tex2D(colormap0, input.texcoord);

    // Adjust it to keep only values brighter than the specified threshold.
    output.color = saturate((color - bloomThreshold) / (1.0f - bloomThreshold));

	return output;
}

FOUTPUTDATA mhorizontalbloom(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float2 samplePosition;
    float4 sum = float4(0.0f);

    for ( float i = -7.0f; i <= 7.0f; i += 1.0f )
    {
        samplePosition = input.texcoord + float2(i * rViewport.x, 0.0f);
        sum += (gauss15x15[i+7] * tex2D(colormap0, samplePosition));
    }

    output.color = float4(sum.rgb, 1.0f);
	return output;
}

FOUTPUTDATA mverticalbloom(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float2 samplePosition;
    float4 sum = float4(0.0f);

    for ( float i = -7.0f; i <= 7.0f; i += 1.0f )
    {
        samplePosition = input.texcoord + float2(0.0f, i * rViewport.y);
        sum += (gauss15x15[i+7] * tex2D(colormap0, samplePosition));
    }

    output.color = float4(sum.rgb, 1.0f);
	return output;
}

float4 AdjustSaturation(float4 color, float saturation)
{
    // second row of the sRGB RGB to XYZ matrix
    float grey = dot(color.rgb, float3(0.2126729f, 0.7151522f, 0.0721750f));

    return lerp(float4(grey), color, saturation);
}

FOUTPUTDATA mcombine(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float4 sceneSample = tex2D(colormap0, input.texcoord);
    float4 bloomSample = tex2D(colormap1, input.texcoord);

    sceneSample = AdjustSaturation(sceneSample, sceneSaturation) * sceneIntensity;
    bloomSample = AdjustSaturation(bloomSample, bloomSaturation) * bloomIntensity;

    sceneSample *= (1.0f - saturate(bloomSample));

    // gamma correction, until now all operations were done in linear space
    output.color = pow(sceneSample + bloomSample, 1.0f/2.2f);
    return output;
}

FOUTPUTDATA mfragmentshader_luminance(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float4 color = tex2D(colormap0, input.texcoord);
    float3 XYZ = mul(color.xyz, RGB2XYZ);

    //Luminance
    output.color.x = max(log(XYZ.y), 0.001f);

	return output;
}

FOUTPUTDATA mfragmentshader_tonemap(VOUTPUTDATA input)
{
	FOUTPUTDATA output;

    float4 color = tex2D(colormap0, input.texcoord);
    float3 XYZ = mul(color.xyz, RGB2XYZ);

    float3 Yxy;
    Yxy.r = XYZ.g;                            // copy luminance Y
    Yxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b ); // x = X / (X + Y + Z)
    Yxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b ); // y = Y / (X + Y + Z)

    // make exposure a parameter
    // make white a parameter

    //float Lscaled = Yxy.r * toneMappingParameters.z / averageLuminance;
    float Lscaled = Yxy.r * toneMappingParameters.z / toneMappingParameters.x;
    Yxy.r = Lscaled * ( 1.0f + ( Lscaled / (toneMappingParameters.y * toneMappingParameters.y) ) ) / (1.0f + Lscaled);

    // Yxy -> XYZ conversion
    XYZ.r = Yxy.r * Yxy.g / Yxy.b;               // X = Y * x / y
    XYZ.g = Yxy.r;                                // copy luminance Y
    XYZ.b = Yxy.r * (1.0f - Yxy.g - Yxy.b) / Yxy.b;  // Z = Y * (1-x-y) / y

    // back to linear RGB, apply gamma correction
    output.color.rgb = pow(mul(XYZ, XYZ2RGB), 1.0f/2.2f);
    output.color.a = 1.0f;

	return output;
}

technique fullscreen
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique bloomextract
{
	pass
	{
		FragmentProgram = compile fp40 mbloomextract();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique horizontalbloom
{
	pass
	{
		FragmentProgram = compile fp40 mhorizontalbloom();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique verticalbloom
{
	pass
	{
		FragmentProgram = compile fp40 mverticalbloom();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique combine
{
	pass
	{
		FragmentProgram = compile fp40 mcombine();
		VertexProgram = compile vp40 mvertexshader();
	}
}

technique luminance
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader_luminance();
		VertexProgram   = compile vp40 mvertexshader();
	}
}

technique tonemap
{
	pass
	{
		FragmentProgram = compile fp40 mfragmentshader_tonemap();
		VertexProgram   = compile vp40 mvertexshader();
	}
}

